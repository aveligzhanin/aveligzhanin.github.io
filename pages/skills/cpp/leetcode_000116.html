<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Populating Next Right Pointers in Each Node (LeetCode)</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- Our style -->
    <link rel="stylesheet" type="text/css" href="/assets/css/styles.css">
	<link rel="stylesheet" type="text/css" href="/assets/css/avel.css">
</head>

  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light navbar-fixed-top">
  <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Сайт Велигжанина Андрея</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse menu">
			<ul class="nav navbar-nav navbar-right">
                 
                    <li>
                       <a href="/index.html#about">Обо мне</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#education">Образование</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#work">Работа</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#skills">Навыки</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#portfolio">Портфолио</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#hobby">Увлечения</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#contact">Контакты</a>
                    </li>
                 
        	</ul>
        </div>
      </div>
  </div>
</nav>

    <section class="pfblock"><div class="container">  		<!-- Translations -->
	<div class="col-xs-6" align=left>
		<a href="/index.html">home</a> \ <a href="/pages/skills/cpp.html">Cpp. Задачки для практики</a>
	</div>

	<div class="col-xs-6" align=right>
		Написано: 20.03.2023
	</div>

   	<div class="col-sm-12 my">
		<h1 id="116-заполнение-правых-указателей-в-каждом-узле-populating-next-right-pointers-in-each-node">116. <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">Заполнение правых указателей в каждом узле (Populating Next Right Pointers in Each Node)</a></h1>

<p><img src="/assets/images/medium.jpg" alt="medium" /></p>

<h2 id="задание">Задание.</h2>

<p>Вам дается идеальное двоичное дерево, где все листья находятся на одном уровне, и у каждого родителя есть два дочерних элемента. Двоичное дерево имеет следующее определение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</code></pre></div></div>

<p>Заполняйте каждый следующий указатель так, чтобы он указывал на его следующий правый узел. Если следующего правого узла нет, следующему указателю должно быть присвоено значение NULL.</p>

<p>Изначально всем следующим указателям присваивается значение NULL.</p>

<h2 id="пример-1">Пример 1.</h2>

<p><img src="/assets/images/LeetCode_000116.jpg" alt="LeetCode-000116" /></p>

<p><strong>Входные данные:</strong> root = [1,2,3,4,5,6,7]</p>

<p><strong>Результат:</strong>  [1,#,2,3,#,4,5,6,7,#]</p>

<p><strong>Объяснение:</strong> Получив приведенное выше идеальное двоичное дерево (рисунок A), ваша функция должна заполнить каждый следующий указатель, чтобы указывать на его следующий правый узел, точно так же, как на рисунке B. Сериализованный вывод находится в порядке уровней, соединенных следующими указателями, причем ‘#’ обозначает конец каждого уровня.</p>

<h2 id="пример-2">Пример 2.</h2>

<p><strong>Входные данные:</strong> root = []</p>

<p><strong>Результат:</strong> []</p>

<h2 id="решение">Решение.</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/</span>

<span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">connect</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>        
        <span class="k">while</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Node</span><span class="o">*</span> <span class="n">rightNode</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>                    <span class="c1">// инициализация rightNode</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>                <span class="c1">// прохождение каждого уровня</span>
                <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>            <span class="c1">// извлечение текущего узла и</span>
                <span class="n">cur</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">rightNode</span><span class="p">;</span>                  <span class="c1">// установка указателя на rightNode</span>
                <span class="n">rightNode</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>                          <span class="c1">// обновление rightNode для следующей итерации</span>
                <span class="k">if</span><span class="p">(</span><span class="n">cur</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">)</span>                          <span class="c1">// если есть потомки,</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">),</span>                 <span class="c1">// помещаем в очередь, сначала правых</span>
                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">);</span>                  <span class="c1">// затем левых</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="способ-решения">Способ решения.</h2>

   	</div>
</div></section>

    <footer class="footer hexlet-footer py-5 mt-5 text-muted">
  <div class="container">
    <div class="row mt-1">
      <div class="col-12 text-center">
        <a href="https://aveligzhanin.github.io/">Велигжанин Андрей</a> — Программист-разработчик C++ и Oracle.
      </div>
    </div>
  </div>
</footer>

  </body>
</html>