<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Параллелизм и согласованность данных</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- Our style -->
    <link rel="stylesheet" type="text/css" href="/assets/css/styles.css">
	<link rel="stylesheet" type="text/css" href="/assets/css/avel.css">
</head>

  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light navbar-fixed-top">
  <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Сайт Велигжанина Андрея</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse menu">
			<ul class="nav navbar-nav navbar-right">
                 
                    <li>
                       <a href="/index.html#about">Обо мне</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#education">Образование</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#work">Работа</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#skills">Навыки</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#portfolio">Портфолио</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#hobby">Увлечения</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#contact">Контакты</a>
                    </li>
                 
        	</ul>
        </div>
      </div>
  </div>
</nav>

    <section class="pfblock"><div class="container">  		<!-- Translations -->
	<div class="col-xs-6" align=left>
		<a href="/index.html">home</a> \ <a href="/pages/skills/oracle/concepts.html">Oracle. Database Concepts</a>
	</div>

	<div class="col-xs-6" align=right>
		Написано: 05.04.2023
	</div>

   	<div class="col-sm-12 my">
		<h1 id="11-параллелизм-и-согласованность-данных"><a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/data-concurrency-and-consistency.html#GUID-E8CBA9C5-58E3-460F-A82A-850E0152E95C">11. Параллелизм и согласованность данных</a></h1>

<p>В этой главе объясняется, как Oracle поддерживает согласованность данных в многопользовательской среде БД.</p>

<h2 id="введение-в-параллелизм-concurrency-и-согласованность-consistency-данных">Введение в параллелизм (Concurrency) и согласованность (Consistency) данных</h2>

<p>В однопользовательской базе данных пользователь может изменять данные, не беспокоясь о том, что другие пользователи изменяют те же данные одновременно. Однако в многопользовательской базе данных инструкции в рамках нескольких одновременных транзакций могут обновлять одни и те же данные. Транзакции, выполняемые одновременно, должны приводить к значимым и последовательным результатам.</p>

<p>Многопользовательская база данных должна обеспечивать следующее:</p>

<ul>
  <li>
    <p>гарантировать, что пользователи могут получать доступ к данным одновременно (<strong>параллелизм данных</strong>)</p>
  </li>
  <li>
    <p>гарантировать, что каждый пользователь видит согласованное представление данных (<strong>data consistency</strong>), включая видимые изменения, внесенные в результате собственных транзакций пользователя и совершенных транзакций других пользователей</p>
  </li>
</ul>

<p>Чтобы описать согласованное поведение транзакций при одновременном выполнении транзакций, исследователи БД определили модель изоляции транзакций, называемую <strong>сериализуемостью</strong>. Сериализуемая транзакция выполняется в среде, которая создает впечатление, что никакие другие пользователи не изменяли данные в БД.</p>

<p>Хотя такая степень изоляции между транзакциями, как правило, желательна, запуск многих приложений в сериализуемом режиме может серьезно снизить пропускную способность приложений. Полная изоляция одновременно выполняемых транзакций может означать, что одна транзакция не может выполнить вставку в таблицу, запрашиваемую другой транзакцией. Короче говоря, реальные соображения обычно требуют компромисса между идеальной изоляцией транзакций и производительностью.</p>

<p>БД Oracle поддерживает согласованность данных с помощью многоверсионной модели согласованности и различных типов блокировок и транзакций. Таким образом, БД может представлять представление данных нескольким одновременным пользователям, причем каждое представление соответствует определенному моменту времени. Поскольку разные версии блоков данных могут существовать одновременно, транзакции могут считывать версию данных, зафиксированную в момент времени, требуемый <strong>запросом</strong>, и вернуть результаты, которые соответствуют одному моменту времени.</p>

<h3 id="согласованность-многоверсионного-чтения">Согласованность многоверсионного чтения</h3>

<p>В БД Oracle <strong>мультиверсионность</strong> – это возможность одновременной материализации нескольких версий данных. БД Oracle поддерживает согласованность чтения в нескольких версиях.</p>

<p>Запросы к базе данных Oracle обладают следующими характеристиками:</p>

<ul>
  <li>
    <p>Запросы, согласованные с чтением<br />Данные, возвращаемые запросом, фиксируются и непротиворечивы для одного момента времени.<br /><strong>Примечание</strong>: БД Oracle никогда не разрешает <strong>грязное чтение</strong>, которое происходит, когда транзакция считывает данные, незафиксированные в другой транзакции.<br />Чтобы проиллюстрировать проблему с грязным чтением, предположим, что одна транзакция обновляет значение столбца без фиксации. Вторая транзакция считывает обновленное и грязное (незафиксированное) значение. Первый сеанс откатывает транзакцию, так что столбец сохраняет свое старое значение, но вторая транзакция продолжается, используя обновленное значение, повреждая БД. Грязные операции чтения нарушают целостность данных, нарушают внешние ключи и игнорируют уникальные ограничения.</p>
  </li>
  <li>
    <p>Неблокирующие запросы<br />Устройства чтения и записи данных не блокируют друг друга.</p>
  </li>
</ul>

<h4 id="согласованность-чтения-уровня-выражений"><strong>Согласованность чтения уровня выражений</strong></h4>

<p>БД Oracle всегда обеспечивает согласованность чтения на уровне инструкций, что гарантирует, что данные, возвращаемые одним запросом, зафиксированы и непротиворечивы в течение одного момента времени.</p>

<p>Момент времени, до которого один оператор SQL является согласованным, зависит от уровня изоляции транзакции и характера запроса:</p>

<ul>
  <li>
    <p>На уровне изоляции зафиксированного чтения (read commited) этот момент является временем, в которое была открыта инструкция. Например, если оператор SELECT открывается в SCN 1000, то этот оператор соответствует SCN 1000.</p>
  </li>
  <li>
    <p>В сериализуемой транзакции (доступной только для чтения), этот момент является временем начала транзакции. Например, если транзакция начинается с SCN 1000, и если в этой транзакции встречается несколько инструкций SELECT, то каждая инструкция соответствует SCN 1000.</p>
  </li>
  <li>
    <p>В операции ретроспективного запроса (SELECT … AS OF), оператор SELECT явно указывает момент времени. Например, вы можете запросить таблицу в том виде, в каком она появилась в прошлый четверг в 14:00.</p>
  </li>
</ul>

<h4 id="согласованность-чтения-уровня-транзакций"><strong>Согласованность чтения уровня транзакций</strong></h4>

<p>БД Oracle также может обеспечивать согласованность чтения для всех запросов в транзакции, известную как согласованность чтения на уровне транзакции.</p>

<p>В этом случае каждый оператор в транзакции видит данные из одного и того же момента времени. Это время, в которое началась транзакция.</p>

<p>Запросы, выполняемые сериализуемой транзакцией, видят изменения, внесенные самой транзакцией. Например, транзакция, которая обновляет сотрудников, а затем запрашивает сотрудников, увидит обновления. Согласованность чтения на уровне транзакции обеспечивает повторяемые чтения и не подвергает запрос фантомным чтениям.</p>

<h4 id="согласованность-чтения-и-undo-сегменты"><strong>Согласованность чтения и Undo-сегменты</strong></h4>

<p>Чтобы управлять многоверсионной моделью согласованности чтения, БД должна создавать согласованный с чтением набор данных при одновременном запросе и обновлении таблицы.</p>

<p>БД Oracle обеспечивает согласованность чтения за счет данных Undo.</p>

<p>Всякий раз, когда пользователь изменяет данные, база данных Oracle создает записи Undo, которые она записывает в сегменты Undo. Сегменты Undo содержат старые значения данных, которые были изменены незафиксированными или недавно зафиксированными транзакциями. Таким образом, в БД может существовать несколько версий одних и тех же данных, все в разные моменты времени. БД может использовать моментальные снимки данных в разные моменты времени, чтобы обеспечить согласованное с чтением представление данных и включить неблокирующие запросы.</p>

<p>Согласованность чтения гарантируется в средах с одним экземпляром и Oracle Real Application Clusters (Oracle RAC). Oracle RAC использует механизм передачи блоков из кэша в кэш, известный как <code class="language-plaintext highlighter-rouge">cache fusion</code>, для передачи совместимых с чтением образов блоков данных из одного экземпляра БД в другой.</p>

<h5 id="согласованность-чтения-пример"><strong>Согласованность чтения: пример</strong></h5>

<p>В этом примере показан запрос, который использует данные Undo для обеспечения согласованности чтения на уровне инструкции на уровне изоляции зафиксированного чтения.</p>

<p><img src="/assets/images/oracon_fig11_1.jpg" alt="OraCon_Fig11_1" /></p>

<p>Поскольку БД извлекает блоки данных от имени запроса, БД гарантирует, что данные в каждом блоке отражают содержимое блока на момент начала запроса. БД откатывает изменения в блоке по мере необходимости, чтобы восстановить блок до момента начала обработки запроса.</p>

<p>БД использует внутренний механизм упорядочения, называемый SCN (System Change Number. Примитив упорядочивания БД. Значение SCN – это логический момент времени, в который вносятся изменения в БД), чтобы гарантировать порядок транзакций. Когда оператор SELECT переходит в фазу выполнения, БД определяет SCN, записанный в момент начала выполнения запроса. На рисунке 11-1 этот SCN равен 10023. Запрос видит только зафиксированные данные в отношении SCN 10023.</p>

<p>На рисунке 11-1 блоки со SCN после 10023 указывают на измененные данные, как показано двумя блоками с SCN 10024. Для инструкции SELECT требуется версия блока, которая соответствует зафиксированным изменениям. БД копирует текущие блоки данных в новый буфер и применяет данные отмены для восстановления предыдущих версий блоков. Эти восстановленные блоки данных называются <strong>клонами согласованного чтения</strong> (CR, consistent read).</p>

<p>На рисунке 11-1 БД создает два клона CR: один блок, соответствующий SCN 10006, и другой блок, соответствующий SCN 10021. БД возвращает восстановленные данные для запроса. Таким образом, БД Oracle предотвращает <strong>грязное чтение</strong>.</p>

<h5 id="согласованность-чтения-и-список-заинтересованных-транзакций-itl--interested-transaction-list"><strong>Согласованность чтения и список заинтересованных транзакций (ITL – interested transaction list)</strong></h5>

<p><strong>Заголовок блока</strong> каждого блока сегмента содержит <strong>список заинтересованных транзакций</strong> (ITL).</p>

<p>БД использует ITL для определения того, была ли транзакция незафиксирована, когда БД начала изменять блок.</p>

<p>Записи в ITL описывают, в каких транзакциях заблокированы строки и какие строки в блоке содержат зафиксированные и незафиксированные изменения. ITL указывает на таблицу транзакций в сегменте Undo, которая предоставляет информацию о моментах внесения изменений в БД.</p>

<p>В некотором смысле заголовок блока содержит недавнюю историю транзакций, которые повлияли на каждую строку в блоке. Параметр <code class="language-plaintext highlighter-rouge">INITRANS</code> инструкций <code class="language-plaintext highlighter-rouge">CREATE TABLE</code> и <code class="language-plaintext highlighter-rouge">ALTER TABLE</code> управляет объемом сохраняемой истории транзакций.</p>

<h4 id="согласованность-чтения-и-отложенные-вставки"><strong>Согласованность чтения и отложенные вставки</strong></h4>

<p>Специальный тип вставки, известный как отложенная вставка, не использует стандартный механизм согласованности чтения.</p>

<p>Отложенная вставка использует подсказку <code class="language-plaintext highlighter-rouge">MEMOPTIMIZER_WRITE</code> для вставки в таблицу, указанную как <code class="language-plaintext highlighter-rouge">MEMOPTIMIZER FOR WRITE</code>. БД буферизует эти вставки в большом пуле, а не в буферном кэше. БД не отслеживает изменения с помощью Undo. Вместо этого БД автоматически фиксирует изменения, когда координатор управления пространством (<code class="language-plaintext highlighter-rouge">SMCO</code>) записывает буфер на диск. Изменения не могут быть отменены.</p>

<p>Отложенные вставки отличаются от обычных важным образом:</p>

<ul>
  <li>
    <p>Данные, находящиеся в большом пуле, который, как предполагает приложение, зафиксирован, могут быть потеряны. Например, экземпляр БД может выйти из строя до того, как изменения будут сохранены на диске, даже если приложение сообщает, что изменения сохранены.</p>
  </li>
  <li>
    <p>Считывание данных непосредственно из памяти запрещено. Программа записи не может прочитать свои собственные изменения до тех пор, пока фоновые процессы не запишут их на диск. Ни один читатель не сможет увидеть зафиксированные изменения до тех пор, пока они не будут записаны на диск.</p>
  </li>
</ul>

<p>Клиентские приложения, которые должны избегать потери данных, должны сохранять локальную копию данных после записи в большой пул. Клиент может использовать пакет <code class="language-plaintext highlighter-rouge">DBMS_MEMOPTIMIZER</code> для отслеживания длительности операций записи в память и пакет <code class="language-plaintext highlighter-rouge">DBMS_MEMOPTIMIZE_ADMIN</code> для принудительной записи БД на диск.</p>

<h3 id="механизм-блокирования">Механизм блокирования</h3>

<p>Как правило, многопользовательские БД используют ту или иную форму блокировки данных для решения проблем, связанных с параллелизмом, согласованностью и целостностью данных.</p>

<p><strong>Блокировка</strong> – это механизм, предотвращающий деструктивное взаимодействие между транзакциями, обращающимися к одному и тому же ресурсу.</p>

<h3 id="уровни-изоляции-транзакций-ansiiso">Уровни изоляции транзакций ANSI/ISO</h3>

<p>Стандарт SQL, который был принят как ANSI, так и ISO/IEC, определяет четыре уровня изоляции транзакций. Эти уровни оказывают различное влияние на пропускную способность обработки транзакций.</p>

<p>Эти уровни изоляции определяются в терминах явлений, которые необходимо предотвращать между одновременно выполняемыми транзакциями. К предотвращаемым явлениям относятся:</p>

<ul>
  <li>
    <p><strong>Грязное считывание</strong><br />Транзакция считывает данные, которые были записаны другой транзакцией, которая еще не была зафиксирована.</p>
  </li>
  <li>
    <p><strong>Неповторяемое</strong> (нечеткое) считывание<br />Транзакция перечитывает данные, которые она ранее прочитала, и обнаруживает, что другая зафиксированная транзакция изменила или удалила данные. Например, пользователь запрашивает строку, а затем позже запрашивает ту же строку, только чтобы обнаружить, что данные изменились.</p>
  </li>
  <li>
    <p><strong>Фантомное считывание</strong><br />Транзакция выполняет запрос, возвращающий набор строк, удовлетворяющий условию поиска, и обнаруживает, что другая зафиксированная транзакция вставила дополнительные строки, удовлетворяющие условию.<br />Например, транзакция запрашивает количество сотрудников. Пять минут спустя он выполняет тот же запрос, но теперь их число увеличилось на единицу, потому что другой пользователь вставил запись для нового найма. Больше данных удовлетворяет критериям запроса, чем раньше, но, в отличие от нечеткого считывания, ранее считанные данные остаются неизменными.</p>
  </li>
</ul>

<p>Стандарт SQL определяет четыре уровня изоляции в терминах явлений, с которыми может столкнуться транзакция, выполняющаяся на определенном уровне изоляции. В таблице 11-1 приведены уровни.</p>

<p><strong>Таблица 11-1 Феномены считывания, предотвращаемые уровнем изоляции</strong></p>

<table class="mbtablestyle1">
  <thead>
    <tr>
      <th>Уровень изоляции</th>
      <th>Грязное считывание</th>
      <th>Неповторяемое считывание</th>
      <th>Фантомное считывание</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Незафиксированное считывание</td>
      <td>возможно</td>
      <td>возможно</td>
      <td>возможно</td>
    </tr>
    <tr>
      <td>Зафиксированное считывание</td>
      <td>не возможно</td>
      <td>возможно</td>
      <td>возможно</td>
    </tr>
    <tr>
      <td>Повторяемое считывание</td>
      <td>не возможно</td>
      <td>не возможно</td>
      <td>возможно</td>
    </tr>
    <tr>
      <td>Сериализуемый</td>
      <td>не возможно</td>
      <td>не возможно</td>
      <td>не возможно</td>
    </tr>
  </tbody>
</table>

<p>БД Oracle Database предлагает уровни изоляции: зафиксированного считывания (по умолчанию) и сериализуемый. Кроме того, БД предлагает режим только для чтения.</p>

<h2 id="обзор-уровней-изоляции-транзакций-бд-oracle">Обзор уровней изоляции транзакций БД Oracle</h2>

<p>Стандарт ANSI для уровней изоляции транзакций определяется в терминах явлений, которые либо разрешены, либо предотвращены для каждого уровня изоляции.</p>

<p>БД Oracle обеспечивает следующие уровни изоляции транзакций:</p>

<ul>
  <li>
    <p>Уровень изоляции зафиксированного считывания</p>
  </li>
  <li>
    <p>Уровень изоляции сериализуемый</p>
  </li>
  <li>
    <p>Уровень изоляции, доступный только для чтения</p>
  </li>
</ul>

<h3 id="уровень-изоляции-зафиксированного-считывания">Уровень изоляции зафиксированного считывания</h3>

<p>На уровне изоляции зафиксированного считывания каждый запрос, выполняемый транзакцией, видит только данные, зафиксированные до начала запроса, а не транзакции.</p>

<p>Этот уровень изоляции установлен по умолчанию. Это подходит для сред БД, в которых вероятность конфликта между несколькими транзакциями невелика.</p>

<p>Запрос в транзакции зафиксированного считывания позволяет избежать чтения данных, которые фиксируются во время выполнения запроса. Например, если запрос находится на середине сканирования таблицы с миллионом строк, и если другая транзакция фиксирует обновление строки 950 000, то запрос не видит этого изменения при чтении строки 950 000. Однако, поскольку БД не запрещает другим транзакциям изменять данные, считываемые запросом, другие транзакции могут изменять данные между выполнением запроса. Таким образом, транзакция, которая дважды выполняет один и тот же запрос, может столкнуться с нечеткими считываниями и фантомными считываниями.</p>

<h4 id="согласованность-чтения-на-уровне-изоляции-зафиксированного-считывания"><strong>Согласованность чтения на уровне изоляции зафиксированного считывания</strong></h4>

<p>БД предоставляет согласованный набор результатов для каждого запроса, гарантируя согласованность данных без каких-либо действий со стороны пользователя.</p>

<p><strong>Неявному запросу</strong>, такому как запрос, подразумеваемый предложением <code class="language-plaintext highlighter-rouge">WHERE</code> в инструкции <code class="language-plaintext highlighter-rouge">UPDATE</code>, гарантируется согласованный набор результатов. Однако каждый оператор в неявном запросе не видит изменений, внесенных самим оператором DML, но видит данные такими, какими они существовали до внесения изменений.</p>

<p>Если список <code class="language-plaintext highlighter-rouge">SELECT</code> содержит функцию PL/SQL, то БД применяет согласованность чтения на уровне инструкции для SQL, выполняемого в коде функции PL/SQL, а не на родительском уровне SQL. Например, функция может получить доступ к таблице, данные которой изменены и зафиксированы другим пользователем. Для каждого выполнения <code class="language-plaintext highlighter-rouge">SELECT</code> в функции создается новый моментальный снимок, совместимый с чтением.</p>

<h4 id="конфликтующие-записи-в-транзакциях-зафиксированного-считывания"><strong>Конфликтующие записи в транзакциях зафиксированного считывания</strong></h4>

<p>В транзакции зафиксированного считывания конфликтующая запись возникает, когда транзакция пытается изменить строку, обновленную незафиксированной параллельной транзакцией.</p>

<p>Транзакцию, которая предотвращает изменение строки, иногда называют блокирующей транзакцией. Транзакция зафиксированного считывания ожидает завершения блокирующей транзакции и снятия блокировки строки.</p>

<p>Возможны следующие варианты:</p>

<ul>
  <li>
    <p>Если блокирующая транзакция откатывается, то ожидающая транзакция переходит к изменению ранее заблокированной строки, как если бы другая транзакция никогда не существовала.</p>
  </li>
  <li>
    <p>Если блокирующая транзакция фиксируется и снимает свои блокировки, то ожидающая транзакция переходит к запланированному обновлению вновь измененной строки.</p>
  </li>
</ul>

<p>В следующей таблице показано, как транзакция 1, которая может быть либо сериализуемой, либо зафиксированного считывания, взаимодействует с транзакцией 2, зафиксированного считывания. Это показывает классическую ситуацию, известную как потерянное обновление. Обновление, внесенное транзакцией 1, отсутствует в таблице, даже несмотря на то, что транзакция 1 зафиксировала его. Разработка стратегии обработки потерянных обновлений является важной частью разработки приложений.</p>

<p><strong>Таблица 11-2 Конфликтующие записи и потерянное обновление в транзакциях зафиксированного считывания</strong></p>

<p><img src="/assets/images/table11_2a.jpg" alt="table11_2a" /> 
<img src="/assets/images/table11_2b.jpg" alt="table11_2b" /> 
<img src="/assets/images/table11_2c.jpg" alt="table11_2c" /> 
<img src="/assets/images/table11_2d.jpg" alt="table11_2d" /></p>

<h3 id="уровень-изоляции-сериализуемый">Уровень изоляции сериализуемый</h3>

<p>На уровне сериализуемой изоляции транзакция видит только изменения, зафиксированные в момент начала транзакции, а не запроса, и изменения, внесенные самой транзакцией.</p>

<p>Сериализуемая транзакция выполняется в среде, которая создает впечатление, что никакие другие пользователи не изменяли данные в БД. Сериализуемая изоляция подходит для различных сред:</p>

<ul>
  <li>
    <p>С большими БД и короткими транзакциями, которые обновляют всего несколько строк</p>
  </li>
  <li>
    <p>Где вероятность того, что две одновременные транзакции изменят одни и те же строки, относительно невелика</p>
  </li>
  <li>
    <p>Где относительно длительные транзакции в основном доступны только для чтения</p>
  </li>
</ul>

<p>При сериализуемой изоляции согласованность чтения, обычно получаемая на уровне инструкции, распространяется на всю транзакцию. Любая строка, прочитанная транзакцией, гарантированно будет одинаковой при чтении. Любой запрос гарантированно возвращает одни и те же результаты на протяжении всей транзакции, поэтому изменения, внесенные другими транзакциями, не видны запросу независимо от того, как долго он выполняется. Сериализуемые транзакции не подвергаются грязному чтению, нечеткому чтению или фантомному чтению.</p>

<p>БД Oracle разрешает сериализуемой транзакции изменять строку только в том случае, если изменения в строке, внесенные другими транзакциями, уже были зафиксированы на момент начала сериализуемой транзакции. БД выдает ошибку, когда сериализуемая транзакция пытается обновить или удалить данные, измененные другой транзакцией, которая была зафиксирована после начала сериализуемой транзакции:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ORA-08177: Cannot serialize access for this transaction
</code></pre></div></div>

<p>При сбое сериализуемой транзакции с ошибкой ORA-08177 приложение может выполнить несколько действий, включая следующие:</p>

<ul>
  <li>
    <p>Закоммитить выполненную работу до этого момента</p>
  </li>
  <li>
    <p>Произвести дополнительные (но отличающиеся) инструкции, возможно, после отката к точке сохранения, установленной ранее в транзакции</p>
  </li>
  <li>
    <p>Откатить всю транзакцию</p>
  </li>
</ul>

<p>В следующей таблице показано, как сериализуемая транзакция взаимодействует с другими транзакциями. Если сериализуемая транзакция не пытается изменить строку, зафиксированную другой транзакцией после начала сериализуемой транзакции, то проблемы с сериализованным доступом удается избежать.</p>

<p><strong>Таблица 11-3 Сериализуемая транзакция</strong></p>

<p><img src="/assets/images/table11_3a.jpg" alt="table11_3a" /> 
<img src="/assets/images/table11_3b.jpg" alt="table11_3b" /> 
<img src="/assets/images/table11_3c.jpg" alt="table11_3c" /> 
<img src="/assets/images/table11_3d.jpg" alt="table11_3d" /> 
<img src="/assets/images/table11_3e.jpg" alt="table11_3e" /> 
<img src="/assets/images/table11_3f.jpg" alt="table11_3f" /> 
<img src="/assets/images/table11_3g.jpg" alt="table11_3g" /></p>

<h3 id="уровень-изоляции-доступный-только-для-чтения">Уровень изоляции, доступный только для чтения</h3>

<p>Уровень <strong>изоляции только для чтения</strong> аналогичен сериализуемому уровню изоляции, но транзакции только для чтения не позволяют изменять данные в транзакции, если пользователь не является <code class="language-plaintext highlighter-rouge">SYS</code>.</p>

<p>Транзакции, доступные только для чтения, не подвержены ошибке <code class="language-plaintext highlighter-rouge">ORA-08177</code>. Транзакции, доступные только для чтения, полезны для создания отчетов, содержимое которых должно соответствовать времени начала транзакции.</p>

<p>БД Oracle обеспечивает согласованность чтения за счет восстановления данных по мере необходимости из Undo-сегментов. Поскольку Undo-сегменты используются циклически, БД может перезаписывать данные отмены. Длительно работающие отчеты сопряжены с риском того, что данные Undo, необходимые для обеспечения согласованности чтения, могли быть повторно использованы другой транзакцией, что приведет к ошибке <code class="language-plaintext highlighter-rouge">snapshot too old</code>. Установка <strong>периода хранения Undo</strong>, который представляет собой минимальное количество времени, в течение которого БД пытается сохранить старые данные отмены перед их перезаписью, соответствующим образом позволяет избежать этой проблемы.</p>

<h2 id="обзор-механизма-блокирования-бд-oracle">Обзор механизма блокирования БД Oracle</h2>

<p><strong>Блокировка</strong> – это механизм, который предотвращает деструктивные взаимодействия.</p>

<p>Взаимодействия являются деструктивными, когда они неправильно обновляют данные или неправильно изменяют базовые структуры данных между транзакциями, получающими доступ к общим данным. Блокировки играют решающую роль в поддержании параллелизма и согласованности БД.</p>

<h3 id="изложение-поведения-блокировки">Изложение поведения блокировки</h3>

<p>БД поддерживает несколько различных типов блокировок, в зависимости от операции, которая получила блокировку.</p>

<p>Как правило, БД использует два типа блокировок: эксклюзивные блокировки и разделяемые блокировки. Для ресурса, такого как строка или таблица, может быть получена только одна эксклюзивная блокировка, но для одного ресурса может быть получено множество разделяемых блокировок.</p>

<p>Блокировки влияют на взаимодействие читателей и писателей. Читатель – это запрос к ресурсу, тогда как писатель – это оператор, изменяющий ресурс. Следующие правила обобщают поведение блокировки БД Oracle для чтения и записи:</p>

<ul>
  <li>
    <p>Строка блокируется только при изменении писателем.<br />Когда оператор обновляет одну строку, транзакция получает блокировку только для этой строки. Блокируя данные таблицы на уровне строк, БД сводит к минимуму конкуренцию за одни и те же данные. При обычных обстоятельствах (1) БД не увеличивает блокировку строки до уровня блока или таблицы.</p>
  </li>
  <li>
    <p>Запись строки блокирует одновременную запись той же строки.<br />Если одна транзакция изменяет строку, то блокировка строки не позволяет другой транзакции изменять ту же строку одновременно.</p>
  </li>
  <li>
    <p>Читатель никогда не блокирует писателя.<br />Поскольку средство чтения строки не блокирует ее, средство записи может изменить эту строку. Единственным исключением является <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code>, которая представляет собой специальный тип инструкции <code class="language-plaintext highlighter-rouge">SELECT</code>, который блокирует строку, которую он считывает.</p>
  </li>
  <li>
    <p>Писатель никогда не блокирует читателя.<br />Когда писатель изменяет строку, БД использует Undo-данные, чтобы предоставить читателям согласованное представление строки.</p>
  </li>
</ul>

<blockquote>
  <p><strong>Примечание</strong>: Читателям данных, возможно, придется ждать записи одних и тех же блоков данных в очень особых случаях ожидающих выполнения распределенных транзакций.</p>
</blockquote>

<h3 id="использование-блокировок">Использование блокировок</h3>

<p>В однопользовательской БД блокировки не нужны, поскольку только один пользователь изменяет информацию. Однако, когда несколько пользователей получают доступ к данным и изменяют их, БД должна обеспечивать способ предотвращения одновременного изменения одних и тех же данных.</p>

<p>Блокировки удовлетворяют следующим важным требованиям к БД:</p>

<ul>
  <li>
    <p>Согласованность<br />Данные, которые просматривает или изменяет сеанс, не должны изменяться другими сеансами до тех пор, пока пользователь не завершит работу.</p>
  </li>
  <li>
    <p>Целостность<br />Данные и структуры должны отражать все внесенные в них изменения в правильной последовательности.</p>
  </li>
</ul>

<p>БД Oracle обеспечивает параллелизм данных, согласованность и целостность транзакций с помощью своих механизмов блокировки. Блокировка происходит автоматически и не требует никаких действий пользователя.</p>

<p>Необходимость блокировок может быть проиллюстрирована одновременным обновлением одной строки. В следующем примере простое веб-приложение предоставляет конечному пользователю адрес электронной почты сотрудника и номер телефона. Приложение использует инструкцию <code class="language-plaintext highlighter-rouge">UPDATE</code>, такую как следующая, для изменения данных:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UPDATE employees
SET    email = ?, phone_number = ?
WHERE  employee_id = ?
AND    email = ?
AND    phone_number = ?
</code></pre></div></div>

<p>В предыдущей инструкции <code class="language-plaintext highlighter-rouge">UPDATE</code> значения электронной почты и номера телефона в предложении <code class="language-plaintext highlighter-rouge">WHERE</code> являются исходными, неизмененными значениями для указанного сотрудника. Это обновление гарантирует, что строка, которую изменяет приложение, не была изменена после того, как приложение в последний раз прочитало и отобразило ее пользователю. Таким образом, приложение позволяет избежать проблемы с потерей обновления, при которой один пользователь перезаписывает изменения, внесенные другим пользователем, фактически теряя обновление вторым пользователем (в таблице 11-2 показан пример потерянного обновления).</p>

<p>В таблице 11-4 показана последовательность событий, когда два сеанса пытаются изменить одну и ту же строку в таблице <code class="language-plaintext highlighter-rouge">employees</code> примерно в одно и то же время.</p>

<p><strong>Таблица 11-4 Пример блокировки строки</strong></p>

<p><img src="/assets/images/table11_4a.jpg" alt="table11_4a" /> 
<img src="/assets/images/table11_4b.jpg" alt="table11_4b" /> 
<img src="/assets/images/table11_4c.jpg" alt="table11_4b" /> 
<img src="/assets/images/table11_4d.jpg" alt="table11_4d" /></p>

<p>БД Oracle автоматически получает необходимые блокировки при выполнении SQL-инструкций. Например, прежде чем БД разрешит сеансу изменять данные, сеанс должен сначала заблокировать данные. Блокировка предоставляет сеансу исключительный контроль над данными, так что никакая другая транзакция не сможет изменить заблокированные данные до тех пор, пока блокировка не будет снята.</p>

<p>Поскольку механизмы блокировки Oracle тесно связаны с управлением транзакциями, разработчикам приложений нужно только правильно определить транзакции, и Oracle автоматически управляет блокировкой. Пользователям никогда не нужно явно блокировать какой-либо ресурс, хотя Oracle также позволяет пользователям блокировать данные вручную.</p>

<p>В следующих разделах объясняются концепции, важные для понимания того, как Oracle обеспечивает параллелизм данных.</p>

<h3 id="режимы-блокировок">Режимы блокировок</h3>

<p>БД Oracle автоматически использует самый низкий применимый уровень ограничений, чтобы обеспечить максимальную степень параллелизма данных, но при этом обеспечить отказоустойчивую целостность данных.</p>

<p>Чем менее ограничительный уровень, тем более доступны данные для доступа других пользователей. И наоборот, чем более ограничительный уровень, тем более ограничены другие транзакции в типах блокировок, которые они могут получить.</p>

<p>Oracle использует два режима блокировки в многопользовательской БД:</p>

<ul>
  <li>
    <p>Режим эксклюзивной блокировки<br />Этот режим предотвращает совместное использование связанного ресурса. Транзакция получает эксклюзивную блокировку, когда она изменяет данные. Первая транзакция, которая блокирует ресурс исключительно, является единственной транзакцией, которая может изменять ресурс до тех пор, пока не будет снята эксклюзивная блокировка.</p>
  </li>
  <li>
    <p>Режим разделяемой блокировки<br />Этот режим позволяет совместно использовать связанный ресурс в зависимости от выполняемых операций. Несколько пользователей, считывающих данные, могут совместно использовать их, каждый из которых имеет разделяемую блокировку, чтобы предотвратить одновременный доступ пользователя, которому требуется эксклюзивная блокировка. Несколько транзакций могут получать блокировки общего доступа к одному и тому же ресурсу.</p>
  </li>
</ul>

<p>Предположим, что транзакция использует <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code>, чтобы выбрать одну строку таблицы. Транзакция получает эксклюзивную блокировку строки и разделяемую блокировку таблицы для доступа к строкам. Блокировка строки позволяет другим сеансам изменять любые строки, отличные от заблокированной строки, в то время как блокировка таблицы не позволяет сеансам изменять структуру таблицы. Таким образом, БД допускает выполнение как можно большего количества инструкций.</p>

<h3 id="преобразование-и-эскалация-блокировок">Преобразование и эскалация блокировок</h3>

<p>БД Oracle выполняет <strong>преобразование блокировки</strong> по мере необходимости.</p>

<p>При преобразовании блокировки БД автоматически преобразует блокировку таблицы с меньшим ограничением в блокировку с более высоким ограничением. Например, предположим, что транзакция выдает <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code> для сотрудника и последующего обновления заблокированной строки. В этом случае БД автоматически преобразует разделяемую блокировку в экслюзивную. Транзакция содержит эксклюзивные блокировки строк для всех строк, вставленных, обновленных или удаленных в рамках транзакции. Поскольку блокировки строк выполняются с наивысшей степенью ограниченности, преобразование блокировок не требуется и не выполняется.</p>

<p>Преобразование блокировок отличается от <strong>эскалации блокировок</strong>, которая происходит, когда многочисленные блокировки удерживаются на одном уровне детализации (например, строки), а БД поднимает блокировки на более высокий уровень детализации (например, таблица). Если сеанс блокирует много строк в таблице, то некоторые БД автоматически увеличивают блокировки строк до одной таблицы. Количество блокировок уменьшается, но увеличивается ограниченность того, что заблокировано.</p>

<p>БД Oracle никогда не эскалирует блокировоки. Эскалация блокировки значительно увеличивает вероятность взаимоблокировок. Предположим, что система пытается эсколировать блокировки от имени транзакции 1, но не может из-за блокировок, удерживаемых транзакцией 2. Взаимоблокировка создается, если транзакция 2 также требует эскалации блокировки тех же данных, прежде чем она сможет быть продолжена.</p>

<h3 id="продолжительность-блокировки">Продолжительность блокировки</h3>

<p>БД Oracle автоматически снимает блокировку при возникновении какого-либо события, при котором транзакции больше не требуется данный ресурс.</p>

<p>Обычно БД хранит блокировки, полученные операторами в рамках транзакции, на время выполнения транзакции. Эти блокировки предотвращают деструктивные помехи, такие как грязное чтение, потерянные обновления и деструктивный DDL от конкурентных транзакций.</p>

<blockquote>
  <p><strong>Примечание:</strong> Блокировка таблицы, примененная к дочерней таблице из-за неиндексированного внешнего ключа, удерживается на время выполнения инструкции, а не транзакции. Кроме того, пакет <code class="language-plaintext highlighter-rouge">DBMS_LOCK</code> позволяет освобождать и распределять пользовательские блокировки по желанию и даже удерживать их за пределами транзакций.</p>
</blockquote>

<p>БД Oracle освобождает все блокировки, полученные операторами в транзакции, когда она фиксируется или откатывается. БД Oracle также освобождает блокировки, полученные после точки сохранения, при откате к точке сохранения. Однако только транзакции, не ожидающие ранее заблокированных ресурсов, могут получать блокировки для доступных в настоящее время ресурсов. Ожидающие транзакции продолжают ждать до тех пор, пока исходная транзакция не зафиксируется или полностью не откатится.</p>

<h3 id="блокировки-и-взаимоблокировки">Блокировки и взаимоблокировки</h3>

<p><strong>Взаимоблокировка</strong> – это ситуация, в которой два или более пользователя ожидают получения данных, заблокированных друг другом. Взаимоблокировки препятствуют продолжению работы некоторых транзакций.</p>

<p>БД Oracle автоматически обнаруживает взаимоблокировки и устраняет их путем отката одного оператора, вовлеченного в взаимоблокировку, освобождая один набор конфликтующих блокировок строк. БД возвращает соответствующее сообщение транзакции, которая подвергается откату на уровне инструкции. Откат инструкции принадлежит транзакции, которая обнаруживает взаимоблокировку. Обычно сигнализируемая транзакция должна быть явно откатана, но она может повторить операцию отката после ожидания.</p>

<p>В таблице 11-5 показаны две транзакции, находящиеся во взаимоблокировке.</p>

<p><strong>Таблица 11-5 Взаимозаблокированные транзакции</strong></p>

<p><img src="/assets/images/table11_5a.jpg" alt="table11_5a" /> 
<img src="/assets/images/table11_5b.jpg" alt="table11_5b" /></p>

<p>Взаимоблокировки чаще всего возникают, когда транзакции явно переопределяют блокировку БД Oracle по умолчанию. Поскольку БД Oracle не эскалирует блокировки и не использует блокировки чтения для запросов, но использует блокировку на уровне строк (а не на уровне страницы), взаимоблокировки возникают нечасто.</p>

<h2 id="обзор-автоматического-блокирования">Обзор автоматического блокирования</h2>

<p>БД Oracle автоматически блокирует ресурс от имени транзакции, чтобы другие транзакции не могли выполнять что-либо, требующее эксклюзивного доступа к тому же ресурсу.</p>

<p>БД автоматически получает различные типы блокировок с различными уровнями ограниченности в зависимости от ресурса и выполняемой операции.</p>

<blockquote>
  <p><strong>Примечание</strong>: БД никогда не блокирует строки при выполнении простого чтения.</p>
</blockquote>

<p>Блокировки БД Oracle разделены на категории, указанные в следующей таблице.</p>

<p><strong>Таблица 11-6 Категории блокировок</strong></p>

<table class="mbtablestyle1">
  <thead>
    <tr>
      <th>Блокировка</th>
      <th>Описание</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Блокировки DML</td>
      <td>Защищает данные. Например, блокировки таблиц блокируют целые таблицы, в то время как блокировки строк блокируют выбранные строки.</td>
    </tr>
    <tr>
      <td>Блокировки DDL</td>
      <td>Защищает структуру объектов схемы – например, словарные определения таблиц и представлений.</td>
    </tr>
    <tr>
      <td>Системные блокировки</td>
      <td>Защита внутренние структуры БД, таких как файлы данных. Защелки, мьютексы и внутренние блокировки выполняются полностью автоматически.</td>
    </tr>
  </tbody>
</table>

<h3 id="блокировки-dml">Блокировки DML</h3>

<p><strong>Блокировка DML</strong>, также называемая <em>блокировкой данных</em>, гарантирует целостность данных, к которым одновременно обращаются несколько пользователей.</p>

<p>Например, блокировка DML не позволяет двум клиентам приобрести последний экземпляр книги, доступный в онлайн-магазине книг. Блокировки DML предотвращают деструктивное вмешательство одновременных конфликтующих операций DML или DDL.</p>

<p>Операторы DML автоматически получают следующие типы блокировок:</p>

<ul>
  <li>
    <p>Строковые блокировки (TX)</p>
  </li>
  <li>
    <p>Табличные блокировки (TM)</p>
  </li>
</ul>

<p>В следующих разделах аббревиатура в круглых скобках после каждого типа блокировки или режима блокировки является аббревиатурой, используемой в мониторе блокировок Oracle Enterprise Manager. Enterprise Manager может отображать TM для любой блокировки таблицы, а не указывать режим блокировки таблицы (такой, как RS или SRX).</p>

<h4 id="строковые-блокировки-tx"><strong>Строковые блокировки (TX)</strong></h4>

<p>Строковая блокировка, также называемая TX-блокировкой, – это блокировка одной строки таблицы. Транзакция получает блокировку строки для каждой строки, измененной с помощью <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>, <code class="language-plaintext highlighter-rouge">MERGE</code> или <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code>. Строковая блокировка существует до тех пор, пока транзакция не зафиксируется или не выполнит откат.</p>

<p>Строковая блокировка в первую очередь служат механизмом постановки в очередь для предотвращения изменения одной и той же строки двумя транзакциями. БД всегда блокирует измененную строку в эксклюзивном режиме, так что другие транзакции не могут изменять строку до тех пор, пока транзакция, удерживающая блокировку, не зафиксирует или не откатит ее. Строковая блокировка обеспечивает наилучшую возможную грануляцию блокирования и, таким образом, обеспечивает наилучший параллелизм и пропускную способность.</p>

<blockquote>
  <p><strong>Примечание:</strong> Если транзакция завершается из-за сбоя <strong>экземпляра БД</strong>, то восстановление на уровне блоков делает строку доступной перед восстановлением всей транзакции.</p>
</blockquote>

<p>Если транзакция получает строчную блокировку, то транзакция получает также и блокировку таблицы, содержащей эту строку. Блокировка таблицы предотвращает конфликтующие операции DDL, которые переопределили бы изменения данных в текущей транзакции. На рисунке 11-2 показано обновление третьей строки в таблице. БД Oracle автоматически устанавливает эксклюзивную блокировку на обновленную строку и субэксклюзивную блокировку на таблицу.</p>

<p><img src="/assets/images/oracon_fig11_2.jpg" alt="oracon_fig11_2" /></p>

<h5 id="строковые-блокировки-и-параллелизм"><strong>Строковые блокировки и параллелизм</strong></h5>

<p>Этот сценарий иллюстрирует, как БД Oracle использует блокировки строк для обеспечения параллелизма.</p>

<p>Три сеанса запрашивают одни и те же строки одновременно. Сеансы 1 и 2 продолжают выполнять незафиксированные обновления для разных строк, в то время как сеанс 3 не производит обновлений. Каждый сеанс видит свои собственные незафиксированные обновления, но не незафиксированные обновления любого другого сеанса.</p>

<p><strong>Таблица 11-7 Пример параллелизма данных</strong></p>

<p><img src="/assets/images/table11_7a.jpg" alt="table11_7a" /> 
<img src="/assets/images/table11_7b.jpg" alt="table11_7b" /> 
<img src="/assets/images/table11_7c.jpg" alt="table11_7c" /></p>

<h5 id="хранилище-строковых-блокировок"><strong>Хранилище строковых блокировок</strong></h5>

<p>В отличие от некоторых БД, которые используют диспетчер блокировок для ведения списка блокировок в памяти, Oracle хранит информацию о блокировке в блоке данных, содержащем заблокированную строку.</p>

<p>БД использует механизм очередей для получения блокировок строк. Если транзакция требует блокировки для незаблокированной строки, то транзакция помещает блокировку в блок данных. Каждая строка, измененная этой транзакцией, указывает на копию идентификатора транзакции, хранящегося в заголовке блока.</p>

<p>Когда транзакция завершается, идентификатор транзакции остается в заголовке блока. Если другая транзакция хочет изменить строку, то она использует идентификатор транзакции, чтобы определить, активна ли блокировка. Если блокировка активна, то сеанс запрашивает уведомление о снятии блокировки. В противном случае транзакция получает блокировку.</p>

<h4 id="табличные-блокировки-tm"><strong>Табличные блокировки (TM)</strong></h4>

<p>Табличная блокировка, также называемая TM-блокировкой, устанавливается транзакцией, когда таблица изменяется с помощью <code class="language-plaintext highlighter-rouge">INSERT</code>, <code class="language-plaintext highlighter-rouge">UPDATE</code>, <code class="language-plaintext highlighter-rouge">DELETE</code>, <code class="language-plaintext highlighter-rouge">MERGE</code>, <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code> или инструкции <code class="language-plaintext highlighter-rouge">LOCK TABLE</code>.</p>

<p>Для операций DML требуются блокировки таблиц, чтобы зарезервировать доступ DML к таблице от имени транзакции и предотвратить операции DDL, которые могли бы конфликтовать с транзакцией.</p>

<p>Блокировка таблицы может удерживаться в любом из следующих режимов:</p>

<ul>
  <li>
    <p>Строчная разделяемая (RS, row share)<br />Эта блокировка, также называемая разделяемой табличной блокировкой (SS), указывает на то, что транзакция, удерживающая блокировку таблицы, заблокировала строки в таблице и намерена их обновить. Разделяемая строчная блокировка – это наименее ограничительный режим блокировки таблицы, обеспечивающий наивысшую степень параллелизма для таблицы.</p>
  </li>
  <li>
    <p>Строчная экслюзивная блокировка таблицы (RX)<br />Эта блокировка, также называемая суб-эксклюзивной блокировкой таблицы (SX), обычно указывает на то, что транзакция, удерживающая блокировку, обновила строки таблицы или выдала <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code>. SX-блокировка позволяет другим транзакциям запрашивать, вставлять, обновлять, удалять или блокировать строки одновременно в одной и той же таблице. Таким образом, SX-блокировки позволяют нескольким транзакциям получать одновременные SX-блокировки и RS-блокировки для одной и той же таблицы.</p>
  </li>
  <li>
    <p>Разделяемая табличная блокировка (S)<br />Разделяемая табличная блокировка, удерживаемая транзакцией, позволяет другим транзакциям запрашивать таблицу (без использования <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code>), но обновления разрешены только в том случае, если одна транзакция удерживает разделяемую табличную блокировку. Поскольку несколько транзакций могут одновременно удерживать разделяемую табличную блокировку, удержания этой блокировки недостаточно для обеспечения того, чтобы транзакция могла изменять таблицу.</p>
  </li>
  <li>
    <p>Эксклюзивная табличная блокировка для разделяемой строки (SRX)<br />Эта блокировка, также называемая разделяемо-субэкслюзивной табличной блокировкой (SSX), является более ограничительной, чем разделяемая табличная блокировка. Только одна транзакция одновременно может получить SSX-блокировку для данной таблицы. SSX-блокировка, удерживаемая транзакцией, позволяет другим транзакциям запрашивать таблицу (за исключением <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code>), но не для обновления таблицы.</p>
  </li>
  <li>
    <p>Эксклюзивная табличная блокировка (X)<br />Эта блокировка является наиболее ограничительной, запрещающей другим транзакциям выполнять любой тип инструкции DML или накладывать любой тип блокировки на таблицу.</p>
  </li>
</ul>

<h4 id="блокировки-и-внешние-ключи"><strong>Блокировки и внешние ключи</strong></h4>

<p>БД Oracle обеспечивает максимальное управление параллелизмом родительских ключей по отношению к зависимым внешним ключам.</p>

<p>Поведение блокировки зависит от того, проиндексированы ли столбцы внешнего ключа. Если внешние ключи не проиндексированы, то дочерняя таблица, вероятно, будет блокироваться чаще, будут возникать взаимоблокировки и уменьшится параллелизм. По этой причине внешние ключи почти всегда должны быть проиндексированы. Единственным исключением является случай, когда соответствующий уникальный или первичный ключ никогда не обновляется и не удаляется.</p>

<h5 id="блокировки-и-неиндексированные-внешние-ключи"><strong>Блокировки и неиндексированные внешние ключи</strong></h5>

<p>БД получает полную блокировку таблицы для дочерней таблицы, когда в столбце внешнего ключа дочерней таблицы не существует индекса, и сеанс изменяет первичный ключ в родительской таблице (например, удаляет строку или изменяет атрибуты первичного ключа) или объединяет строки в родительскую таблицу.</p>

<p>Когда оба из следующих условий выполняются, БД получает полную блокировку таблицы для дочерней таблицы:</p>

<ul>
  <li>
    <p>В столбце внешнего ключа дочерней таблицы не существует индекса.</p>
  </li>
  <li>
    <p>Сеанс изменяет первичный ключ в родительской таблице (например, удаляет строку или изменяет атрибуты первичного ключа) или объединяет строки в родительскую таблицу.</p>
  </li>
</ul>

<blockquote>
  <p><strong>Примечание:</strong> Вставки в родительскую таблицу не получают блокирующих блокировок таблицы, которые предотвращают DML в дочерней таблице. В случае вставок БД получает блокировку дочерней таблицы, которая предотвращает структурные изменения, но не модификации существующих или вновь добавленных строк.</p>
</blockquote>

<p>Предположим, что таблица <code class="language-plaintext highlighter-rouge">hr.departments</code> является родительской для <code class="language-plaintext highlighter-rouge">hr.employees</code>, которая содержит неиндексированный внешний ключ <code class="language-plaintext highlighter-rouge">employees.department_id</code>. На следующем рисунке показан сеанс, изменяющий атрибуты первичного ключа отдела <strong>60</strong> в таблице <code class="language-plaintext highlighter-rouge">departments</code>.</p>

<p><img src="/assets/images/oracon_fig11_3.jpg" alt="oracon_fig11_3" /></p>

<p>На рисунке 11-3 БД получает полную блокировку таблицы для <code class="language-plaintext highlighter-rouge">hr.employees</code> во время модификации первичного ключа отдела 60. Эта блокировка позволяет другим сеансам запрашивать таблицу <code class="language-plaintext highlighter-rouge">employees</code>, но не обновлять ее. Например, сеансы не могут обновлять телефонные номера сотрудников. Блокировка таблицы для <code class="language-plaintext highlighter-rouge">employees</code> снимается сразу после завершения модификации первичного ключа в таблице <code class="language-plaintext highlighter-rouge">departments</code>. Если несколько строк в отделах подвергаются изменениям первичного ключа, то блокировка таблицы для <code class="language-plaintext highlighter-rouge">employees</code> получается и снимается один раз для каждой строки, измененной в <code class="language-plaintext highlighter-rouge">departments</code>.</p>

<blockquote>
  <p><strong>Примечание:</strong> DML в дочерней таблице не требуется табличная блокировка в родительской таблице.</p>
</blockquote>

<h5 id="блокировки-и-индекированные-внешние-ключи"><strong>Блокировки и индекированные внешние ключи</strong></h5>

<p>БД не получает полной блокировки таблицы для дочерней таблицы, когда столбец внешнего ключа в дочерней таблице индексируется, и сеанс изменяет первичный ключ в родительской таблице (например, удаляет строку или изменяет атрибуты первичного ключа) или объединяет строки в родительскую таблицу.</p>

<p>Блокировка родительской таблицы предотвращает получение транзакциями эксклюзивных табличных блокировок, но не предотвращает DML в родительской или дочерней таблице во время модификации первичного ключа. Эта ситуация предпочтительнее, если изменения первичного ключа происходят в родительской таблице, в то время как обновления происходят в дочерней таблице.</p>

<p>На рисунке 11-4 показана дочерняя таблица <code class="language-plaintext highlighter-rouge">employees</code> с индексированным столбцом <code class="language-plaintext highlighter-rouge">department_id</code>. Транзакция удаляет отдел 280 из таблицы <code class="language-plaintext highlighter-rouge">departments</code>. Это удаление не приводит к тому, что БД получает полную блокировку таблицы <code class="language-plaintext highlighter-rouge">employees</code>, как в сценарии, описанном в разделе “Блокировки и неиндексированные внешние ключи”.</p>

<p><img src="/assets/images/oracon_fig11_4.jpg" alt="oracon_fig11_4" /></p>

<p>Если дочерняя таблица специфицируется, как <code class="language-plaintext highlighter-rouge">ON DELETE CASCADE</code>, то удаления из родительской таблицы могут привести к удалениям из дочерней таблицы. Например, удаление отдела 280 может привести к удалению записей от сотрудников для <code class="language-plaintext highlighter-rouge">employees</code> в удаленном отделе <code class="language-plaintext highlighter-rouge">departments</code>. В этом случае правила ожидания и блокировки такие же, как если бы вы удалили строки из дочерней таблицы после удаления строк из родительской таблицы.</p>

<h3 id="блокировки-ddl">Блокировки DDL</h3>

<p>Блокировка словаря данных (DDL) защищает определение объекта схемы, пока текущая операция DDL воздействует на объект или ссылается на него.</p>

<p>Только отдельные объекты схемы, которые изменены или на которые ссылаются, блокируются во время операций DDL. БД никогда не блокирует весь словарь данных.</p>

<p>БД Oracle автоматически получает блокировку DDL от имени любой транзакции DDL, требующей этого. Пользователи не могут явно запрашивать блокировки DDL. Например, если пользователь создает хранимую процедуру, то БД Oracle автоматически получает блокировки DDL для всех объектов схемы, на которые ссылаются в определении процедуры. Блокировки DDL предотвращают изменение или удаление этих объектов до завершения компиляции процедуры.</p>

<h4 id="эксклюзивные-ddl-блокировки"><strong>Эксклюзивные DDL-блокировки</strong></h4>

<p>Эксклюзивная DDL-блокировка не позволяет другим сеансам получать блокировку DDL или DML.</p>

<p>Большинство операций DDL требуют эксклюзивных DDL-блокировок для ресурса, чтобы предотвратить деструктивное вмешательство в другие операции DDL, которые могут изменять один и тот же объект схемы или ссылаться на него. Например, <code class="language-plaintext highlighter-rouge">DROP TABLE</code> не позволяет удалять таблицу, пока <code class="language-plaintext highlighter-rouge">ALTER TABLE</code> добавляет к ней столбец, и наоборот.</p>

<p>Эксклюзивные DDL-блокировки сохраняются на время выполнения инструкции DDL и автоматической фиксации. Во время получения эксклюзивной DDL-блокировки, если другая DDL-блокировка удерживается на объекте схемы другой операцией, то получение ожидает, пока более старая DDL-блокировка не будет снята, а затем продолжается.</p>

<h4 id="разделяемые-ddl-блокировки"><strong>Разделяемые DDL-блокировки</strong></h4>

<p>Разделяемая DDL-блокировка для ресурса предотвращает деструктивное вмешательство в конфликтующие операции DDL, но допускает параллелизм данных для аналогичных операций DDL.</p>

<p>Например, когда выполняется инструкция <code class="language-plaintext highlighter-rouge">CREATE PROCEDURE</code>, содержащая транзакция получает общие блокировки DDL для всех таблиц, на которые ссылаются. Другие транзакции могут одновременно создавать процедуры, которые ссылаются на одни и те же таблицы, и получать одновременные разделяемые DDL-блокировки для одних и тех же таблиц, но ни одна транзакция не может получить эксклюзивную DDL-блокировку для любой таблицы, на которую ссылается.</p>

<p>Разделяемая DDL-блокировка сохраняется на время выполнения инструкции DDL и автоматической фиксации. Таким образом, транзакция, содержащая разделяемую DDL-блокировку, гарантирует, что определение объекта схемы, на который ссылается ссылка, остается постоянным во время транзакции.</p>

<h4 id="разрушаемые-блокировки-синтаксического-анализа"><strong>Разрушаемые блокировки синтаксического анализа</strong></h4>

<p>Блокировка синтаксического анализа удерживается оператором SQL или программным модулем PL/SQL для каждого объекта схемы, на который он ссылается.</p>

<p>Блокировки синтаксического анализа приобретаются таким образом, чтобы связанная общая область SQL могла быть признана недействительной, если объект, на который ссылается ссылка, изменен или удален. Блокировка синтаксического анализа называется разрушаемой блокировкой синтаксического анализа, поскольку она не запрещает какую-либо операцию DDL и может быть нарушена, чтобы разрешить конфликтующие операции DDL.</p>

<p>Блокировка синтаксического анализа устанавливается в общем пуле на этапе синтаксического анализа выполнения инструкции SQL. Блокировка удерживается до тех пор, пока общая область SQL для этого оператора остается в общем пуле.</p>

<h3 id="системные-блокировки">Системные блокировки</h3>

<p>Oracle использует различные типы системных блокировок для защиты внутренних структур БД и памяти. Эти механизмы недоступны для пользователей, поскольку пользователи не имеют никакого контроля над их возникновением или продолжительностью.</p>

<h4 id="защелки-latches"><strong>Защелки (Latches)</strong></h4>

<p><strong>Защелка</strong> – это простой низкоуровневый механизм сериализации, который координирует многопользовательский доступ к общим структурам данных, объектам и файлам.</p>

<p>Защелки защищают ресурсы общей памяти от повреждения при доступе к ним нескольких процессов. В частности, защелки защищают структуры данных от следующих ситуаций:</p>

<ul>
  <li>
    <p>Одновременное изменение несколькими сеансами</p>
  </li>
  <li>
    <p>Считывание в одном сеансе во время изменения в другом сеансе</p>
  </li>
  <li>
    <p>Перераспределение памяти при ее использовании</p>
  </li>
</ul>

<p>Как правило, одна защелка защищает несколько объектов в SGA. Например, фоновые процессы, такие как DBW и LGWR, выделяют память из <strong>общего пула</strong> для создания структур данных. Чтобы выделить эту память, эти процессы используют защелку для общего пула, которая сериализует доступ, чтобы предотвратить одновременную попытку двух процессов проверить или изменить общий пул. После выделения памяти другим процессам может потребоваться доступ к разделяемым областям пула, таким как <strong>библиотечный кэш</strong>, который необходим для синтаксического анализа. В этом случае процессы защелкивают только библиотечный кэш, а не весь общий пул.</p>

<p>В отличие от блокировок, использующих очередь, таких как блокировки строк, защелки не позволяют сеансам помещаться в очередь. Когда защелка становится доступной, первый сеанс, запросивший защелку, получает к ней эксклюзивный доступ. Явление вращения защелки возникает, когда процесс повторно запрашивает защелку в цикле, тогда как спящий режим защелки возникает, когда процесс освобождает центральный процессор перед возобновлением запроса защелки.</p>

<p>Как правило, процесс Oracle получает защелку на чрезвычайно короткое время при манипулировании структурой данных или просмотре ее. Например, при обработке обновления заработной платы одного сотрудника БД может получать и освобождать тысячи защелок. Реализация защелок зависит от операционной системы, особенно в отношении того, ожидает ли процесс защелки и как долго.</p>

<p>Увеличение защелок означает уменьшение параллелизма. Например, чрезмерно сложные операции синтаксического анализа создают конфликт для блокировки библиотечного кэша. Представление <code class="language-plaintext highlighter-rouge">V$LATCH</code> содержит подробную статистику использования защелки для каждой защелки, включая количество раз, когда каждая защелка была запрошена и ожидалась.</p>

<h4 id="мьютексы"><strong>Мьютексы</strong></h4>

<p><strong>Взаимно-исключаемый объект (мьютекс)</strong> – это низкоуровневый механизм, который предотвращает устаревание или повреждение объекта в памяти при обращении к нему параллельных процессов. Мьютекс похож на защелку, но в то время как защелка обычно защищает группу объектов, мьютекс защищает один объект.</p>

<p>Мьютексы предоставляют несколько преимуществ:</p>

<ul>
  <li>
    <p>Мьютекс может уменьшить вероятность конфликта.<br />Поскольку защелка защищает несколько объектов, она может стать узким местом, когда процессы пытаются получить доступ к любому из этих объектов одновременно. Сериализуя доступ к отдельному объекту, а не к группе, мьютекс повышает доступность.</p>
  </li>
  <li>
    <p>Мьютекс потребляет меньше памяти, чем защелка.</p>
  </li>
  <li>
    <p>В разделяемом режиме, мьютекс позволяет одновременные ссылки для нескольких сеансов.</p>
  </li>
</ul>

<h4 id="внутренние-блокировки"><strong>Внутренние блокировки</strong></h4>

<p><strong>Внутренние блокировки</strong> являются высокоуровневыми, более сложными механизмами, чем защелки и мьютексы, и служат различным целям.</p>

<p>БД использует следующие типы внутренних блокировок:</p>

<ul>
  <li>
    <p>Блокировки кэша словаря<br />Эти блокировки имеют очень короткий срок действия и удерживаются для записей в кэшах словаря, пока эти записи изменяются или используются. Они гарантируют, что анализируемые операторы не увидят несогласованных определений объектов. Блокировки кэша словаря могут быть разделяемыми или эксклюзивными. Разделяемые блокировки снимаются по завершении синтаксического анализа, в то время как эксклюзивные блокировки снимаются по завершении операции DDL.</p>
  </li>
  <li>
    <p>Блокировки управления файлами и журналами<br />Эти блокировки защищают различные файлы. Например, внутренняя блокировка защищает управляющий файл таким образом, что только один процесс одновременно может его изменять. Другая блокировка координирует использование и архивирование файлов журнала повтора в режиме онлайн. Файлы данных заблокированы, чтобы гарантировать, что несколько экземпляров подключат БД в разделяемом режиме или что один экземпляр подключит ее в эксклюзивном режиме. Поскольку блокировки файлов и журналов указывают на состояние файлов, эти блокировки обязательно удерживаются в течение длительного времени.</p>
  </li>
  <li>
    <p>Блокировки табличного пространства и Undo-сегментов<br />Эти блокировки защищают табличные пространства и Undo-сегменты. Например, все экземпляры, обращающиеся к БД, должны согласовать, является ли табличное пространство интерактивным или автономным. Undo-сегменты блокируются, так что только один экземпляр БД может выполнять запись в сегмент.</p>
  </li>
</ul>

<h2 id="обзор-ручного-блокирования-данных">Обзор ручного блокирования данных</h2>

<p>Вы можете вручную переопределить механизмы блокировки БД Oracle по умолчанию.</p>

<p>БД Oracle выполняет блокировку автоматически, чтобы обеспечить параллелизм данных, целостность данных и согласованность чтения на уровне инструкций. Однако переопределение блокировки по умолчанию полезно в таких ситуациях, как следующие:</p>

<ul>
  <li>
    <p>Приложениям требуется согласованность чтения на уровне транзакций или повторяемого считывания.<br />В этом случае запросы должны выдавать согласованные данные на протяжении всей транзакции, не отражая изменений, внесенных другими транзакциями. Вы можете добиться согласованности чтения на уровне транзакции, используя явную блокировку, транзакции только для чтения, сериализуемые транзакции или переопределяя блокировку по умолчанию.</p>
  </li>
  <li>
    <p>Приложения требуют, чтобы транзакция имела эксклюзивный доступ к ресурсу, чтобы транзакции не приходилось ждать завершения других транзакций.</p>
  </li>
</ul>

<p>Вы можете переопределить автоматическую блокировку БД Oracle на уровне сеанса или транзакции. На уровне сеанса сеанс может установить требуемый уровень изоляции транзакции с помощью инструкции <code class="language-plaintext highlighter-rouge">ALTER SESSION</code>. На уровне транзакций транзакции, включающие следующие инструкции SQL, переопределяют блокировку БД Oracle по умолчанию:</p>

<ul>
  <li>
    <p>Инструкцией <code class="language-plaintext highlighter-rouge">SET TRANSACTION ISOLATION LEVEL</code></p>
  </li>
  <li>
    <p>Инструкцией <code class="language-plaintext highlighter-rouge">LOCK TABLE</code> (которая блокироует либо таблицу, либо базовые таблицы, входящие в представление)</p>
  </li>
  <li>
    <p>Инструкцией <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code></p>
  </li>
</ul>

<p>Блокировки, полученные с помощью предыдущих инструкций, снимаются после завершения транзакции или отката к точке сохранения.</p>

<p>Если блокировка БД Oracle по умолчанию переопределена на любом уровне, то администратор БД или разработчик приложения должны убедиться, что переопределяющие процедуры блокировки работают правильно. Процедуры блокировки должны удовлетворять следующим критериям: целостность данных гарантирована, параллелизм данных приемлем, взаимоблокировки невозможны или обрабатываются надлежащим образом.</p>

<h2 id="обзор-блокирования-определяемого-пользователем">Обзор блокирования, определяемого пользователем</h2>

<p>С помощью служб Oracle Database Lock Management services вы можете определять свои собственные блокировки для конкретного приложения.</p>

<p>Например, вы могли бы создать блокировку для сериализации доступа к журналу сообщений в файловой системе. Поскольку зарезервированная блокировка пользователя – это то же самое, что блокировка БД Oracle, она обладает всеми функциями блокировки БД Oracle, включая обнаружение взаимоблокировок. Пользовательские блокировки никогда не конфликтуют с блокировками БД Oracle, поскольку они идентифицируются с помощью префикса <code class="language-plaintext highlighter-rouge">UL</code>.</p>

<p>Службы управления блокировкой БД Oracle доступны с помощью процедур в пакете <code class="language-plaintext highlighter-rouge">DBMS_LOCK</code>. Вы можете включать инструкции в блоки PL/SQL, которые:</p>

<ul>
  <li>
    <p>Запрашивают блокировку определенного типа</p>
  </li>
  <li>
    <p>Присваивают блокировке уникальное имя, распознаваемое в другой процедуре в том же или в другом экземпляре</p>
  </li>
  <li>
    <p>Изменяют тип блокировки</p>
  </li>
  <li>
    <p>Снимают блокровку</p>
  </li>
</ul>

<p><br /><br /><br /><br /><br /><br /><br /></p>
<div class="row">
  <div class="col"><div align="left"><a href="/pages/skills/oracle/concept/10plsql.html">&#8592; 10. Программирование на стороне сервера: PL/SQL и Java.</a></div>
  </div>
  <div class="col"><div align="right"><a href="/pages/skills/oracle/concept/12transactions.html">12. Транзакции &#8594;</a></div> 
 </div> 
</div>

   	</div>
</div></section>

    <footer class="footer hexlet-footer py-5 mt-5 text-muted">
  <div class="container">
    <div class="row mt-1">
      <div class="col-12 text-center">
        <a href="https://aveligzhanin.github.io/">Велигжанин Андрей</a> — Программист-разработчик C++ и Oracle.
      </div>
    </div>
  </div>
</footer>

  </body>
</html>