<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Транзакции</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- Our style -->
    <link rel="stylesheet" type="text/css" href="/assets/css/styles.css">
	<link rel="stylesheet" type="text/css" href="/assets/css/avel.css">
</head>

  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light navbar-fixed-top">
  <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Сайт Велигжанина Андрея</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse menu">
			<ul class="nav navbar-nav navbar-right">
                 
                    <li>
                       <a href="/index.html#about">Обо мне</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#education">Образование</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#work">Работа</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#skills">Навыки</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#portfolio">Портфолио</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#hobby">Увлечения</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#contact">Контакты</a>
                    </li>
                 
        	</ul>
        </div>
      </div>
  </div>
</nav>

    <section class="pfblock"><div class="container">  		<!-- Translations -->
	<div class="col-xs-6" align=left>
		<a href="/index.html">home</a> \ <a href="/pages/skills/oracle/concepts.html">Oracle. Database Concepts</a>
	</div>

	<div class="col-xs-6" align=right>
		Написано: 05.04.2023
	</div>

   	<div class="col-sm-12 my">
		<h1 id="12-транзакции"><a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/transactions.html#GUID-B97790CB-DF82-442D-B9D5-50CCE6BF9FBD">12. Транзакции</a></h1>

<p>В этой главе дается определение транзакции и описывается, как БД обрабатывает транзакции.</p>

<h2 id="введение-в-транзакции">Введение в транзакции</h2>

<p><strong>Транзакция</strong> – это логическая, атомарная единица работы, содержащая один или несколько операторов SQL.</p>

<p>Транзакция группирует SQL-инструкции таким образом, что либо все они фиксируются, что означает, что они применяются к БД, либо все откатываются, что означает, что они удаляются из БД. БД Oracle присваивает каждой транзакции уникальный идентификатор, называемый <strong>transaction ID</strong>.</p>

<p>Все транзакции Oracle соблюдают основные свойства транзакции БД, известные как свойства ACID. ACID – это аббревиатура от следующего:</p>

<ul>
  <li>
    <p><strong>Атомарность</strong><br />Выполняются все задачи транзакции или не выполняется ни одна из них. Частичных транзакций не существует. Например, если транзакция начинает обновлять 100 строк, но система завершается сбоем после 20 обновлений, то БД откатывает изменения в эти 20 строк.</p>
  </li>
  <li>
    <p><strong>Согласованность (Consistency)</strong><br />Транзакция переводит БД из одного согласованного состояния в другое. Например, в банковской транзакции, которая дебетует сберегательный счет и зачисляет средства на расчетный счет, сбой не должен приводить к тому, что БД зачисляет средства только на один счет, что привело бы к несогласованности данных.</p>
  </li>
  <li>
    <p><strong>Изолированность</strong><br />Эффект транзакции не виден другим транзакциям до тех пор, пока транзакция не будет зафиксирована. Например, один пользователь, обновляющий таблицу <code class="language-plaintext highlighter-rouge">hr.employees</code>, не видит незафиксированных изменений в <code class="language-plaintext highlighter-rouge">employees</code>, внесенных одновременно другим пользователем. Таким образом, пользователям кажется, что транзакции выполняются последовательно.</p>
  </li>
  <li>
    <p><strong>Долговечность</strong><br />Изменения, внесенные зафиксированными транзакциями, являются постоянными. После завершения транзакции БД с помощью своих механизмов восстановления гарантирует, что изменения, внесенные в транзакцию, не будут потеряны.</p>
  </li>
</ul>

<p>Использование транзакций является одним из наиболее важных отличий между СУБД и файловой системой.</p>

<h3 id="пример-транзакции-дебет-и-кредит-счета">Пример транзакции: дебет и кредит счета</h3>

<p>Для иллюстрации концепции транзакции, рассмотрим банковскую БД.</p>

<p>Когда клиент переводит деньги со сберегательного счета на расчетный счет, транзакция должна состоять из трех отдельных операций:</p>

<ul>
  <li>
    <p>Уменьшение сберегательного счета</p>
  </li>
  <li>
    <p>Увеличение расчетного счета</p>
  </li>
  <li>
    <p>Запись о транзакции в журнале транзакций</p>
  </li>
</ul>

<p>БД Oracle должна допускать две ситуации. Если все три инструкции SQL поддерживают баланс учетных записей в надлежащем состоянии, то последствия транзакции могут быть применены к БД. Однако, если такая проблема, как нехватка средств, неверный номер счета или аппаратный сбой, не позволяет выполнить одну или две операции из транзакции, БД должна выполнить откат всей транзакции, чтобы баланс всех счетов был правильным.</p>

<p>Следующий рисунок иллюстрирует банковскую транзакцию. Первая операция вычитает 500 долларов со сберегательного счета 3209. Вторая операция добавляет 500 долларов к текущему счету 3208. Третья инструкция вставляет запись о передаче в таблицу журнала. Заключительный оператор фиксирует транзакцию.</p>

<p><img src="/assets/images/oracon_fig12_1.jpg" alt="oracon_fig12_1" /></p>

<h3 id="структура-транзакции">Структура транзакции</h3>

<p>Транзакция БД состоит из одного или нескольких операторов.</p>

<p>В частности, транзакция состоит из одного из следующих действий:</p>

<ul>
  <li>
    <p>Один или несколько операторов языка обработки данных (<strong>DML</strong>), которые вместе представляют собой атомарное изменение БД</p>
  </li>
  <li>
    <p>Оператор языка определения данных (<strong>DDL</strong>)</p>
  </li>
</ul>

<p>Транзакция имеет начало и конец.</p>

<h4 id="начало-транзакции"><strong>Начало транзакции</strong></h4>

<p>Транзакция начинается при выполнении первого исполняемого SQL-оператора.</p>

<p><strong>Исполняемый SQL-оператор</strong> – это SQL-оператор, который генерирует вызовы экземпляра БД, включая инструкции DML и DDL и инструкцию <code class="language-plaintext highlighter-rouge">SET TRANSACTION</code>.</p>

<p>Когда транзакция начинается, БД Oracle назначает транзакцию доступному сегменту Undo, чтобы записать Undo-записи для новой транзакции. Идентификатор транзакции не выделяется до тех пор, пока не будут выделены Undo-сегмент и слот таблицы транзакций, что происходит во время первой инструкции DML. Идентификатор транзакции уникален для транзакции и представляет собой номер сегмента отмены, слот и порядковый номер.</p>

<p>В следующем примере выполняется инструкция <code class="language-plaintext highlighter-rouge">UPDATE</code> для начала транзакции и запрашивается <code class="language-plaintext highlighter-rouge">V$TRANSACTION</code> для получения подробной информации о транзакции:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SQL&gt; UPDATE hr.employees SET salary=salary; 

107 rows updated.
 
SQL&gt; SELECT XID AS "txn id", XIDUSN AS "undo seg", XIDSLOT AS "slot", 
  2  XIDSQN AS "seq", STATUS AS "txn status"
  3  FROM V$TRANSACTION;
 
txn id             undo seg       slot        seq txn status
---------------- ---------- ---------- ---------- ----------------
0600060037000000          6          6         55 ACTIVE
</code></pre></div></div>

<h4 id="окончание-транзакции"><strong>Окончание транзакции</strong></h4>

<p>Транзакция может завершиться при различных обстоятельствах.</p>

<p>Транзакция завершается, когда выполняется любое из следующих действий:</p>

<ul>
  <li>
    <p>Пользователь выдает инструкцию COMMIT или ROLLBACK без указания SAVEPOINT.<br />При фиксации пользователь явно или неявно запросил, чтобы изменения в транзакции стали постоянными. Изменения, внесенные транзакцией, являются постоянными и видны другим пользователям только после фиксации транзакции.</p>
  </li>
  <li>
    <p>Пользователь запускает команду DDL, такую как <code class="language-plaintext highlighter-rouge">CREATE</code>, <code class="language-plaintext highlighter-rouge">DROP</code>, <code class="language-plaintext highlighter-rouge">RENAME</code> или <code class="language-plaintext highlighter-rouge">ALTER</code>.<br />БД выдает неявный оператор COMMIT до и после каждого оператора DDL. Если текущая транзакция содержит инструкции DML, то Oracle Database сначала фиксирует транзакцию, а затем запускает и фиксирует инструкцию DDL как новую транзакцию с одним оператором.</p>
  </li>
  <li>
    <p>Пользователь обычно завершает работу с большинством утилит и инструментов Oracle Database utilities, в результате чего текущая транзакция неявно фиксируется. Поведение фиксации при отключении пользователя зависит от приложения и настраивается.<br /><strong>Примечание:</strong> Приложения всегда должны явно фиксировать или отменять транзакции перед завершением работы программы.</p>
  </li>
  <li>
    <p>Клиентский процесс завершается ненормально, что приводит к неявному откату транзакции с использованием метаданных, хранящихся в таблице транзакций, и сегмента Undo.</p>
  </li>
</ul>

<p>После завершения одной транзакции следующая исполняемая инструкция SQL автоматически запускает следующую транзакцию. В следующем примере выполняется <code class="language-plaintext highlighter-rouge">UPDATE</code> для запуска транзакции, завершается транзакция с помощью инструкции <code class="language-plaintext highlighter-rouge">ROLLBACK</code>, а затем выполняется <code class="language-plaintext highlighter-rouge">UPDATE</code> для запуска новой транзакции (обратите внимание, что идентификаторы транзакций разные):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SQL&gt; UPDATE hr.employees SET salary=salary; 
107 rows updated.
 
SQL&gt; SELECT XID, STATUS FROM V$TRANSACTION;
 
XID              STATUS
---------------- ----------------
0800090033000000 ACTIVE
 
SQL&gt; ROLLBACK;
 
Rollback complete.
 
SQL&gt; SELECT XID FROM V$TRANSACTION;
 
no rows selected
 
SQL&gt; UPDATE hr.employees SET last_name=last_name;
 
107 rows updated.
 
SQL&gt; SELECT XID, STATUS FROM V$TRANSACTION;
 
XID              STATUS
---------------- ----------------
0900050033000000 ACTIVE
</code></pre></div></div>

<h3 id="атомарность-на-уровне-оператора">Атомарность на уровне оператора</h3>

<p>БД Oracle поддерживает атомарность на уровне оператора, что означает, что SQL-оператор является атомарной единицей работы и либо полностью выполняется успешно, либо завершается с ошибкой.</p>

<p>Успешный оператор отличается от зафиксированной транзакции. Один SQL-оператор выполняется успешно, если БД анализирует и запускает его без ошибок как атомарную единицу, например, когда все строки изменяются при многострочном обновлении.</p>

<p>Если SQL-оператор вызывает ошибку во время выполнения, значит, он не является успешным, и поэтому все последствия оператора отменяются. Эта операция представляет собой откат на уровне оператора. Эта операция имеет следующие характеристики:</p>

<ul>
  <li>
    <p>Оператор SQL, который не выполняется успешно, приводит к потере только работы, которую он выполнил бы сам.<br />Неудачное выполнение оператора не приводит к потере какой-либо работы, которая предшествовала ему в текущей транзакции. Например, если выполнение второго оператора по обновлению в “Примере транзакции: Дебет и кредит счета” вызывает ошибку и выполняется откат, то работа, выполненная первым оператором по <code class="language-plaintext highlighter-rouge">UPDATE</code>, не откатывается. Первая инструкция <code class="language-plaintext highlighter-rouge">UPDATE</code> может быть зафиксирована или откатана пользователем явно.</p>
  </li>
  <li>
    <p>Эффект отката такой, как если бы оператор никогда не выполнялся.<br />Любые побочные эффекты атомарного оператора, например, триггеры, вызываемые при выполнении оператора, считаются частью атомарного оператора. Либо вся работа, сгенерированная как часть атомарного оператора, завершается успешно, либо ни одна из них не выполняется.</p>
  </li>
</ul>

<p>Примером ошибки, вызывающей откат на уровне оператора, является попытка вставить дубликат первичного ключа. Отдельные операторы SQL, вовлеченные в взаимоблокировку, которая представляет собой конкуренцию за одни и те же данные, также могут вызвать откат на уровне оператора. Однако ошибки, обнаруженные во время синтаксического анализа SQL-оператора, такие как синтаксическая ошибка, еще не были запущены и поэтому не вызывают откат на уровне оператора.</p>

<h3 id="номера-системных-изменений">Номера системных изменений</h3>

<p><strong>Номер системного изменения (SCN)</strong> – это логическая внутренняя временная метка, используемая БД Oracle.</p>

<p>SCNs упорядочивают события, происходящие в БД, что необходимо для удовлетворения ACID-свойств транзакции. БД Oracle использует SCNs для пометки SCN, перед который, как известно, все изменения находятся на диске, чтобы избежать ненужного повтора при восстановлении. БД также использует SCNs для обозначения точки, в которой невозможен повтор для набора данных, чтобы можно было остановить восстановление.</p>

<p>SCN происходит в монотонно возрастающей последовательности. БД Oracle может использовать SCN как часы, поскольку наблюдаемый SCN указывает логический момент времени, а повторные наблюдения возвращают равные или большие значения. Если одно событие имеет более низкий SCN, чем другое событие, то оно произошло в БД в более раннее время. Несколько событий могут использовать один и тот же SCN, что означает, что они произошли в БД в одно и то же время.</p>

<p>У каждой транзакции есть SCN. Например, если транзакция обновляет строку, то БД записывает SCN, в котором произошло это обновление. Другие изменения в этой транзакции имеют тот же SCN. Когда транзакция фиксируется, БД записывает SCN для этой фиксации.</p>

<p>БД Oracle увеличивает SCNs в глобальной области системы (SGA). Когда транзакция изменяет данные, БД записывает новый SCN в Undo-сегмент, назначенный транзакции. Затем процесс записи журнала немедленно записывает запись о фиксации транзакции в оперативный redo-журнал. Запись фиксации имеет уникальный SCN транзакции. Oracle Database также использует SCNs как часть своих механизмов восстановления экземпляров и носителей.</p>

<h2 id="обзор-управления-транзакциями">Обзор управления транзакциями</h2>

<p>Управление транзакциями – это управление изменениями, вносимыми операторами DML, и группирование инструкций DML в транзакции.</p>

<p>Как правило, разработчики приложений заботятся о контроле транзакций, чтобы работа выполнялась в логических единицах и данные сохранялись согласованными.</p>

<p>Управление транзакциями предполагает использование следующих инструкций, как описано в разделе “Инструкции по управлению транзакциями”:</p>

<ul>
  <li>
    <p>Оператор <code class="language-plaintext highlighter-rouge">COMMIT</code> завершает текущую транзакцию и делает все изменения, выполненные в транзакции, постоянными. <code class="language-plaintext highlighter-rouge">COMMIT</code> также стирает все точки сохранения в транзакции и снимает блокировки транзакций.</p>
  </li>
  <li>
    <p>Оператор <code class="language-plaintext highlighter-rouge">ROLLBACK</code> отменяет работу, выполненную в текущей транзакции; это приводит к отбрасыванию всех изменений данных с момента последней COMMIT-а или ROLLBACK-а. Инструкция <code class="language-plaintext highlighter-rouge">ROLLBACK TO SAVEPOINT</code> отменяет изменения с момента последней точки сохранения, но не завершает всю транзакцию.</p>
  </li>
  <li>
    <p>Оператор <code class="language-plaintext highlighter-rouge">SAVEPOINT</code> определяет в транзакции точку, к которой позже можно выполнить откат.</p>
  </li>
</ul>

<p>Сеанс, приведенный в таблице 12-1, иллюстрирует основные концепции управления транзакциями.</p>

<p><img src="/assets/images/oracon_fig12_1a.jpg" alt="oracon_fig12_1a" /> 
<img src="/assets/images/oracon_fig12_1b.jpg" alt="oracon_fig12_1b" /> 
<img src="/assets/images/oracon_fig12_1c.jpg" alt="oracon_fig12_1c" /></p>

<h3 id="наименования-транзакций">Наименования транзакций</h3>

<p>Имя транзакции – это необязательный, задаваемый пользователем тег, который служит напоминанием о работе, выполняемой транзакцией. Вы называете транзакцию с помощью оператора <code class="language-plaintext highlighter-rouge">SET TRANSACTION ... NAME</code>, который, если используется, должен быть первым оператором транзакции.</p>

<p>В таблице 12-1 первая транзакция была названа <code class="language-plaintext highlighter-rouge">sal_update</code>, а вторая – <code class="language-plaintext highlighter-rouge">sal_update 2</code>.</p>

<p>Именованная транзакция предоставляют следующие преимущества:</p>

<ul>
  <li>
    <p>Проще мониторить длительные транзакции и разрешать сомнительные распределенные транзакции.</p>
  </li>
  <li>
    <p>Можно просматривать имена транзакций вместе с идентификаторами транзакций в приложениях. Например, DBA может просматривать имена транзакций в Oracle Enterprise Manager (Корпоративный менеджер) при мониторинге активности системы.</p>
  </li>
  <li>
    <p>БД записывает имена транзакций в redo-запись аудита транзакций, поэтому вы можете использовать LogMiner для поиска конкретной транзакции в redo-журнале.</p>
  </li>
  <li>
    <p>Можно использовать имена транзакций, чтобы найти конкретную транзакцию в представлениях словаря данных, таких как <code class="language-plaintext highlighter-rouge">V$TRANSACTION</code>.</p>
  </li>
</ul>

<h3 id="активные-транзакции">Активные транзакции</h3>

<p><strong>Активной</strong> является транзакция, которая началась, но еще не зафиксирована или не откатана.</p>

<p>В таблице 12-1 первой операцией по изменению данных в транзакции <code class="language-plaintext highlighter-rouge">sale_update</code> является обновление заработной платы <code class="language-plaintext highlighter-rouge">Banda</code>. С момента успешного выполнения этого обновления до завершения транзакции оператором <code class="language-plaintext highlighter-rouge">ROLLBACK</code> транзакция <code class="language-plaintext highlighter-rouge">sale_update</code> активна.</p>

<p>Изменения данных, внесенные транзакцией, являются временными до тех пор, пока транзакция не будет зафиксирована или откатана. Перед завершением транзакции состояние данных будет таким, как показано в следующей таблице.</p>

<p><strong>Таблица 12-2 Состояние данных перед завершением транзакции</strong></p>

<table class="mbtablestyle1">
  <thead>
    <tr>
      <th>Состояние</th>
      <th>Описание</th>
      <th>Подробности</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>БД Oracle сгенерировала undo-информацию в SGA.</td>
      <td>Undo-данные содержат старые значения данных, измененные SQL-операторами транзакции.</td>
      <td><a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/data-concurrency-and-consistency.html#GUID-432C4EDC-F7F2-467C-B85F-4E82D3D58A2F">Read Consistency in the Read Committed Isolation Level</a></td>
    </tr>
    <tr>
      <td>БД Oracle сгенерировала redo в оперативном буфере redo-журнала SGA.</td>
      <td>Запись redo-журнала содержит изменение в блоке данных и изменение в undo.</td>
      <td><a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/memory-architecture.html#GUID-C2AD1BF6-A5AE-42E9-9677-0AA08126864B">Redo Log Buffer</a></td>
    </tr>
    <tr>
      <td>Были внесены изменения в буферы базы данных SGA.</td>
      <td>Изменения данных для зафиксированной транзакции, хранящиеся в буферах базы данных SGA, не обязательно немедленно записываются в файлы данных программой записи БД (DBW). Запись на диск может произойти до или после фиксации.</td>
      <td><a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/memory-architecture.html#GUID-4FF66585-E469-4631-9225-29D75594CD14">Database Buffer Cache</a></td>
    </tr>
    <tr>
      <td>Заблокированы строки, на которые повлияло изменение данных.</td>
      <td>Другие пользователи не могут изменять данные в затронутых строках и не могут видеть незафиксированные изменения.</td>
      <td><a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/data-concurrency-and-consistency.html#GUID-1D60EFCC-03F4-4A04-B099-1B4DE5D02C47">Summary of Locking Behavior</a></td>
    </tr>
  </tbody>
</table>

<h3 id="точки-сохранения">Точки сохранения</h3>

<p><strong>Точка сохранения</strong> – это объявленный пользователем промежуточный маркер в контексте транзакции.</p>

<p>Внутренне маркер точки сохранения преобразуется в SCN. Точки сохранения делят длительную транзакцию на более мелкие части.</p>

<p>Если вы используете точки сохранения в длительной транзакции, то позже у вас есть возможность откатить работу, выполненную до текущей точки транзакции, но после объявленной точки сохранения в транзакции. Таким образом, если вы допустите ошибку, вам не нужно повторно отправлять каждое утверждение. Таблица 12-1 создает точку сохранения <code class="language-plaintext highlighter-rouge">after_banda_sal</code> также для того, чтобы обновление зарплаты <code class="language-plaintext highlighter-rouge">Greene</code> можно было откатить до этой точки сохранения.</p>

<h4 id="откат-к-точке-сохранения"><strong>Откат к точке сохранения</strong></h4>

<p>Откат к точке сохранения в незафиксированной транзакции означает отмену любых изменений, внесенных после указанной точки сохранения, но это не означает откат самой транзакции.</p>

<p>Когда транзакция откатывается к точке сохранения, как при выполнении <code class="language-plaintext highlighter-rouge">ROLLBACK TO SAVEPOINT after_banda_sal</code> в таблице 12-1, происходит следующее:</p>

<ol>
  <li>
    <p>БД Oracle откатывает только инструкции, выполненные после точки сохранения.<br />В таблице 12-1 ОТКАТ К ТОЧКЕ СОХРАНЕНИЯ приводит к откату ОБНОВЛЕНИЯ для <code class="language-plaintext highlighter-rouge">Greene</code>, но не ОБНОВЛЕНИЯ для <code class="language-plaintext highlighter-rouge">Banda</code>.</p>
  </li>
  <li>
    <p>БД Oracle сохраняет точку сохранения, указанную в инструкции <code class="language-plaintext highlighter-rouge">ROLLBACK TO SAVEPOINT</code>, но все последующие точки сохранения теряются.<br />В таблице 12-1 ОТКАТ К ТОЧКЕ СОХРАНЕНИЯ приводит к потере точки сохранения <code class="language-plaintext highlighter-rouge">after_greene_sal</code>.</p>
  </li>
  <li>
    <p>БД Oracle освобождает все блокировки таблиц и строк, полученные после указанной точки сохранения, но сохраняет все блокировки данных, полученные до точки сохранения.</p>
  </li>
</ol>

<p>Транзакция остается активной и может быть продолжена.</p>

<h4 id="очередь-транзакций"><strong>Очередь транзакций</strong></h4>

<p>В зависимости от сценария, транзакции, ожидающие ранее заблокированных ресурсов, все еще могут быть заблокированы после отката к точке сохранения.</p>

<p>Когда транзакция блокируется другой транзакцией, она ставит в очередь саму блокирующую транзакцию, так что вся блокирующая транзакция должна быть зафиксирована или откатана для продолжения заблокированной транзакции.</p>

<p>В сценарии, показанном в следующей таблице, сеанс 1 выполняет откат к точке сохранения, созданной до выполнения инструкции DML. Однако сеанс 2 по-прежнему заблокирован, поскольку он ожидает завершения транзакции сеанса 1.</p>

<p><img src="/assets/images/oracon_fig12_3a.jpg" alt="oracon_fig12_3a" /> 
<img src="/assets/images/oracon_fig12_3b.jpg" alt="oracon_fig12_3b" /></p>

<h3 id="откат-транзакции">Откат транзакции</h3>

<p>Откат незафиксированной транзакции отменяет все изменения в данных, которые были выполнены SQL-операторами внутри транзакции.</p>

<p>После отката транзакции последствия работы, выполненной в транзакции, больше не существуют. При откате всей транзакции без ссылки на какие-либо точки сохранения БД Oracle выполняет следующие действия:</p>

<ul>
  <li>
    <p>Отменяет все изменения, внесенные всеми SQL-операторами в транзакции, используя соответствующие сегменты Undo<br />Запись таблицы транзакций для каждой активной транзакции содержит указатель на все Undo-данные (в обратном порядке применения) для транзакции. БД считывает Undo-данные, отменяет операцию, а затем помечает Undo-запись как примененную. Таким образом, если транзакция вставляет строку, то откат удаляет ее. Если транзакция обновляет строку, то откат отменяет обновление. Если транзакция удаляет строку, то откат повторно вставляет ее. В таблице 12-1 ОТКАТ отменяет обновления заработной платы Грина и Банды.</p>
  </li>
  <li>
    <p>Освобождает все блокировки данных, удерживаемые транзакцией</p>
  </li>
  <li>
    <p>Удаляет все точки сохранения в транзакции<br />В таблице 12-1 при ОТКАТЕ удаляется точка сохранения <code class="language-plaintext highlighter-rouge">after_banda_sal</code>. Точка сохранения <code class="language-plaintext highlighter-rouge">after_greene_sal</code> была удалена с помощью инструкции <code class="language-plaintext highlighter-rouge">ROLLBACK TO SAVEPOINT</code>.</p>
  </li>
  <li>
    <p>Завершает транзакцию<br />В таблице 12-1 показано, что ОТКАТ оставляет БД в том же состоянии, в котором она была после выполнения первоначальной ФИКСАЦИИ.</p>
  </li>
</ul>

<p>Продолжительность отката зависит от объема измененных данных.</p>

<h3 id="фиксация-транзакции">Фиксация транзакции</h3>

<p>Фиксация завершает текущую транзакцию и делает постоянными все изменения, выполненные в транзакции.</p>

<p>В таблице 12-1 вторая транзакция начинается с <code class="language-plaintext highlighter-rouge">sal_update2</code> и заканчивается явным оператором фиксации. Изменения, внесенные в результате двух инструкций по обновлению, теперь стали постоянными.</p>

<p>Когда транзакция фиксируется, выполняются следующие действия:</p>

<ul>
  <li>
    <p>БД генерирует SCN для ФИКСАЦИИ.<br />Внутренняя таблица транзакций для связанного табличного пространства Undo записывает, что транзакция была зафиксирована. Соответствующий уникальный SCN транзакции присваивается и записывается в таблицу транзакций.</p>
  </li>
  <li>
    <p>Процесс записи журнала (LGWR) записывает оставшиеся записи redo-журнала из буферов redo-журнала в оперативный redo-журнал и записывает SCN транзакции в оперативный redo-журнал. Это атомарное событие представляет собой фиксацию транзакции.</p>
  </li>
  <li>
    <p>БД Oracle освобождает блокировки, удерживаемые в строках и таблицах.<br />Пользователям, которые были поставлены в очередь в ожидании блокировок, удерживаемых незафиксированной транзакцией, разрешается продолжить свою работу.</p>
  </li>
  <li>
    <p>БД Oracle выполняет <strong>очистку фиксации</strong>.<br />Если измененные блоки, содержащие данные из зафиксированной транзакции, все еще находятся в SGA, и если ни один другой сеанс не изменяет их, то БД удаляет из блоков информацию о транзакции, связанную с блокировкой (запись ITL).<br />В идеале, <code class="language-plaintext highlighter-rouge">COMMIT</code> очищает блоки, чтобы последующему <code class="language-plaintext highlighter-rouge">SELECT</code> не приходилось выполнять эту задачу. Если для определенной строки не существует записи <code class="language-plaintext highlighter-rouge">ITL</code>, то она не заблокирована. Если запись <code class="language-plaintext highlighter-rouge">ITL</code> существует для определенной строки, то она, возможно, заблокирована, поэтому сеанс должен проверить заголовок undo-сегмента, чтобы определить, была ли зафиксирована эта заинтересованная транзакция. Если заинтересованная транзакция зафиксирована, то сеанс очищает redo-блок. Однако, если ФИКСАЦИЯ ранее очистила ITL, то проверка и очистка не нужны.<br /><strong>Примечание:</strong> Поскольку очистка блока генерирует redo, запрос может сгенерировать redo и, таким образом, вызвать запись блоков во время следующей контрольной точки.</p>
  </li>
  <li>
    <p>БД Oracle помечает транзакцию как завершенную.</p>
  </li>
</ul>

<p>После фиксации транзакции пользователи могут видеть изменения.</p>

<p>Как правило, фиксация – это быстрая операция, независимо от размера транзакции. Скорость фиксации не увеличивается с увеличением размера данных, измененных в транзакции. Самая длинная часть фиксации – это ввод-вывод с физического диска, выполняемый <code class="language-plaintext highlighter-rouge">LGWR</code>. Однако количество времени, затрачиваемого <code class="language-plaintext highlighter-rouge">LGWR</code>, сокращается, поскольку он постепенно записывает содержимое буфера redo-журнала в фоновом режиме.</p>

<p>Поведение по умолчанию заключается в том, что <code class="language-plaintext highlighter-rouge">LGWR</code> синхронно записывает redo в онлайн-журнал redo, а транзакции ожидают, пока буферизованный redo окажется на диске, прежде чем возвращать фиксацию пользователю. Однако для снижения задержки фиксации транзакции разработчики приложений могут указать, что запись redo должна выполняться асинхронно, чтобы транзакциям не нужно было ждать, пока redo будет на диске, и они могли немедленно вернуться из вызова ФИКСАЦИИ.</p>

<h2 id="обзор-охранителя-транзакций">Обзор охранителя транзакций</h2>

<p><strong>Transaction Guard</strong> – это API, который приложения могут использовать для обеспечения <strong>идемпотентности транзакции</strong>, то есть способности БД сохранять гарантированный результат фиксации, который указывает, была ли транзакция зафиксирована и завершена. БД Oracle предоставляет API для JDBC thin, OCI, OCCI и ODP.Net .</p>

<p>Исправляемая ошибка вызвана внешним системным сбоем, не зависящим от логики выполняемого сеанса приложения. Исправимые ошибки возникают после запланированных и незапланированных отключений основных процессов, сетей, узлов, хранилищ и баз данных. Если сбой прерывает соединение между клиентским приложением и БД, то приложение получает сообщение об ошибке отключения. Транзакция, которая выполнялась при разрыве соединения, называется транзакцией-в-полете.</p>

<p>Чтобы решить, отправлять ли транзакцию повторно или вернуть результат (зафиксированный или незафиксированный) клиенту, приложение должно определить результат транзакции-в-полете. До Oracle Database 12c сообщения о фиксации, возвращаемые клиенту, не были постоянными. Проверка транзакции не была гарантией того, что она не будет зафиксирована после проверки, что допускало дублирование транзакций и другие формы логического повреждения. Например, пользователь может обновить веб-браузер при покупке книги онлайн и получить двойную плату за одну и ту же книгу.</p>

<h3 id="преимущества-охранителя-транзакций">Преимущества охранителя транзакций</h3>

<p>Начиная с Oracle Database 12c, Transaction Guard предоставляет приложениям инструмент для определения статуса транзакции в процессе выполнения после восстановимого сбоя.</p>

<p>Используя Transaction Guard, приложение может гарантировать, что транзакция выполняется не более одного раза. Например, если приложение книжного онлайн-магазина определяет, что ранее отправленная фиксация завершилась неудачей, то приложение может безопасно отправить ее повторно.</p>

<p>Transaction Guard предоставляет инструмент для одноразововго выполнения, чтобы приложение не производило повторных коммитов. Transaction Guard обеспечивает известный результат для каждой транзакции.</p>

<p>Transaction Guard – это основная функция БД Oracle. Непрерывность работы приложения использует Transaction Guard для маскировки сбоев со стороны конечных пользователей. Без защиты транзакций повторная попытка приложения после ошибки может привести к фиксации повторяющихся транзакций.</p>

<h3 id="как-работает-охранитель-транзакций">Как работает охранитель транзакций</h3>

<p>В этом разделе объясняется проблема потерянных сообщений о фиксации и то, как Transaction Guard использует логические идентификаторы транзакций для решения проблемы.</p>

<h4 id="сообщения-о-неверном-коммите"><strong>Сообщения о неверном коммите</strong></h4>

<p>При проектировании с учетом идемпотентности разработчики должны решить проблему сбоев связи после отправки инструкций фиксации. Сообщения о фиксации не сохраняются в БД и поэтому не могут быть восстановлены после сбоя.</p>

<p>Следующий рисунок представляет собой высокоуровневое представление взаимодействия между клиентским приложением и БД.</p>

<p><img src="/assets/images/oracon_fig12_2.jpg" alt="oracon_fig12_2" /></p>

<p>В стандартном случае фиксации БД фиксирует транзакцию и возвращает клиенту сообщение об успешном завершении. На рисунке 12-2 клиент отправляет инструкцию фиксации и получает сообщение о том, что связь не удалась. Этот тип сбоя может произойти по нескольким причинам, включая сбой экземпляра БД или отключение сети. В этом сценарии клиент не знает о состоянии транзакции.</p>

<p>После сбоя связи БД может все еще выполнять отправку и не знать, что клиент отключился. Проверка состояния транзакции не гарантирует, что активная транзакция не будет зафиксирована после проверки. Если клиент повторно отправит фиксацию из-за этой устаревшей информации, то БД может повторить транзакцию, что приведет к логическому повреждению.</p>

<h4 id="логический-transaction-id"><strong>Логический Transaction ID</strong></h4>

<p>Oracle Database решает проблему сбоя связи с помощью глобально-уникального идентификатора, называемого логическим идентификатором транзакции.</p>

<p>Этот идентификатор содержит логический номер сеанса, выделяемый при первом подключении сеанса, и номер текущей фиксации, который обновляется каждый раз, когда сеанс фиксируется или откатывается. С точки зрения приложения логический идентификатор транзакции однозначно идентифицирует последнюю транзакцию БД, отправленную в сеансе, завершившемся с ошибкой.</p>

<p>Для каждого цикла обработки от клиента, в ходе которой совершается одна или несколько транзакций, в БД сохраняется логический идентификатор транзакции. Этот идентификатор может обеспечить идемпотентность транзакции для взаимодействий между приложением и БД при каждом цикле обработки, при котором фиксируются данные.</p>

<p>Протокол “единственной обработки” обеспечивает доступ к результату фиксации, требуя от БД выполнения следующего:</p>

<ul>
  <li>
    <p>Ведёт логический идентификатор транзакции в течение периода хранения, согласованного для повторной попытки</p>
  </li>
  <li>
    <p>Сохраняет логический идентификатор транзакции при фиксации</p>
  </li>
</ul>

<p>Во время выполнения транзакции как БД, так и клиент хранят логический идентификатор транзакции. БД предоставляет клиенту логический идентификатор транзакции при аутентификации, при заимствовании из пула подключений и при каждом цикле обработки от драйвера клиента, который выполняет одну или несколько операций фиксации.</p>

<p>Прежде чем приложение сможет определить результат последней транзакции после исправляемой ошибки, приложение получает логический идентификатор транзакции, хранящийся на клиенте, используя Java, OCI, OCCI или ODP.Net API. Затем приложение вызывает процедуру PL/SQL <code class="language-plaintext highlighter-rouge">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> с логическим идентификатором транзакции, чтобы определить результат последней отправки: зафиксировано (<code class="language-plaintext highlighter-rouge">true</code> или <code class="language-plaintext highlighter-rouge">false</code>) и завершено (<code class="language-plaintext highlighter-rouge">true</code> или <code class="language-plaintext highlighter-rouge">false</code>).</p>

<p>При использовании Transaction Guard приложение может воспроизводить транзакции, когда ошибка исправима и последняя транзакция в сеансе не была зафиксирована. Приложение может продолжить работу после завершения последней транзакции и пользовательского вызова. Приложение может использовать Transaction Guard для возврата клиенту известного результата, чтобы клиент мог принять решение о следующем действии.</p>

<h3 id="пример-охранителя-транзакций">Пример охранителя транзакций</h3>

<p>В этом сценарии сообщение о фиксации теряется из-за исправимой ошибки.</p>

<p>Защита транзакций использует логический идентификатор транзакции для сохранения результата инструкции COMMIT, гарантируя, что результат транзакции известен.</p>

<p><img src="/assets/images/oracon_fig12_3.jpg" alt="oracon_fig12_3" /></p>

<p>На рисунке 12-3 БД информирует приложение о том, зафиксирована ли транзакция и завершен ли последний вызов пользователя. Затем приложение может вернуть результат конечному пользователю. Возможности заключаются в следующем:</p>

<ul>
  <li>
    <p>Если транзакция зафиксирована и вызов пользователя завершен, то приложение может вернуть результат конечному пользователю и продолжиться.</p>
  </li>
  <li>
    <p>Если транзакция зафиксирована, но вызов пользователя не завершен, то приложение может вернуть результат конечному пользователю с предупреждениями. Примеры включают потерянную привязку или потерянное количество обработанных строк. Некоторые приложения зависят от дополнительной информации, в то время как другие этого не делают.</p>
  </li>
  <li>
    <p>Если пользовательский вызов не был зафиксирован, то приложение может вернуть эту информацию конечному пользователю или безопасно отправить повторно. Соблюдение протокола гарантировано. Когда статус фиксации возвращает значение <code class="language-plaintext highlighter-rouge">false</code>, фиксация последней отправки блокируется.</p>
  </li>
</ul>

<p><strong>Смотри подробнее:</strong> <a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/adfns/transaction-guard.html#GUID-6C5880E5-C45F-4858-A069-A28BB25FD1DB">Oracle Database Development Guide</a></p>

<h2 id="обзор-непрерывности-работы-приложения">Обзор непрерывности работы приложения</h2>

<p><strong>Непрерывность работы приложений</strong> пытается замаскировать сбои в работе приложений путем замены неполных запросов приложений после незапланированных и запланированных отключений. В этом контексте запрос – это единица работы приложения.</p>

<p>Обычно запрос соответствует операторам DML и другим вызовам БД одного веб-запроса при единственном подключении к БД. В общем случае запрос разграничивается вызовами, выполняемыми между извлечением и регистрацией подключения к БД из пула подключений.</p>

<h3 id="преимущества-непрерывности-работы-приложения">Преимущества непрерывности работы приложения</h3>

<p>Основная проблема для разработчиков заключается в том, как скрыть потерянный сеанс БД от конечных пользователей.</p>

<p>Application Continuity пытается решить проблему потерянного сеанса путем восстановления сеанса БД, когда какой-либо компонент прерывает диалог между БД и клиентом. Восстановленный сеанс БД включает в себя все состояния, курсоры, переменные и самую последнюю транзакцию, если таковая существует.</p>

<h4 id="варианты-использования-непрерывности-работы-приложения"><strong>Варианты использования непрерывности работы приложения</strong></h4>

<p>В типичном случае клиент отправил запрос в БД, которая создала как транзакционные, так и нетранзакционные состояния.</p>

<p>Состояние на клиенте остается текущим, потенциально с введенными данными, возвращенными данными и кэшированными данными и переменными. Однако состояние сеанса БД, в пределах которого приложение должно работать, теряется.</p>

<p>Если запрос клиента инициировал одну или несколько транзакций, то приложение сталкивается со следующими возможностями:</p>

<ul>
  <li>
    <p>Если был выдан <code class="language-plaintext highlighter-rouge">COMMIT</code>, то сообщение о фиксации, возвращенное клиенту, не является долговременным. Клиент не знает, зафиксирован ли запрос и в каком состоянии нетранзакционной обработки он был достигнут.</p>
  </li>
  <li>
    <p>Если <code class="language-plaintext highlighter-rouge">COMMIT</code> не был принят или если был принят, но не был выполнен, то транзакция-в-полете откатывается и должна быть повторно отправлена с использованием сеанса в правильном состоянии.</p>
  </li>
</ul>

<p>Если воспроизведение прошло успешно, то обслуживание пользователей БД при плановых и незапланированных отключениях не прерывается. Если БД обнаруживает изменения в просмотренных данных и потенциально воздействует на них приложением, то повторное воспроизведение отклоняется. Попытка воспроизведения не выполняется, если превышено время, отведенное для запуска воспроизведения, приложение использует ограниченный вызов или приложение явно отключило воспроизведение с помощью метода <code class="language-plaintext highlighter-rouge">disableReplay</code>.</p>

<h4 id="непрерывности-работы-приложения-для-планового-сопровождения"><strong>Непрерывности работы приложения для планового сопровождения</strong></h4>

<p>Непрерывность работы приложений при запланированных отключениях позволяет приложениям продолжать работу в течение сеансов базы данных, которые могут быть надежно отключены или перенесены.</p>

<p>Плановое техническое обслуживание не должно нарушать работу приложения. Непрерывность работы приложения позволяет перенести активное рабочее время из его текущего местоположения в новое местоположение, на которое в настоящее время не влияет техническое обслуживание. По истечении интервала прерывания сеансы могут оставаться в экземпляре БД, где планируется техническое обслуживание. Вместо принудительного отключения этих сеансов, Application Continuity может выполнить останов по этим сеансам на сохранившемся сайте и повторно отправить любые транзакции в процессе работы.</p>

<p>Если Application Continuity включена, БД может выполнять следующее:</p>

<ul>
  <li>
    <p>Сообщать во время технического обслуживания об отсутствии ошибок как для входящих, так и для существующих работ.</p>
  </li>
  <li>
    <p>Перенаправлять активные сеансы БД на другие функциональные службы.</p>
  </li>
  <li>
    <p>При необходимости производить перебалансировку сеансов БД данных во время и после технического обслуживания.</p>
  </li>
</ul>

<p>Во время планового технического обслуживания производится управление поведением с помощью служебных атрибутов <code class="language-plaintext highlighter-rouge">drain_timeout</code> и <code class="language-plaintext highlighter-rouge">stop_option</code> утилиты <code class="language-plaintext highlighter-rouge">SRVCTL</code>, Global Data Services Control Utility (<code class="language-plaintext highlighter-rouge">GDSCTL</code>) и Oracle Data Guard Broker. Пакет DBMS_SERVICE предоставляет базовую инфраструктуру.</p>

<h3 id="архитектура-непрерывности-работы-приложения">Архитектура непрерывности работы приложения</h3>

<p>Ключевыми компонентами непрерывности работы приложения являются среда выполнения, переподключение и повторное воспроизведение.</p>

<p>Этапы заключаются в следующем:</p>

<p>1. Обычное время выполнения<br />На этом этапе непрерывность работы приложения выполняет следующие задачи:</p>

<ul>
  <li>
    <p>Идентифицирует запросы к БД</p>
  </li>
  <li>
    <p>Решает, являются ли вызовы БД локальными или воспроизводимыми</p>
  </li>
  <li>
    <p>Создает, при необходимости, прокси-объекты для разрешения воспроизводимости и для управления очередями</p>
  </li>
  <li>
    <p>Удерживает исходные вызовы и проверку этих вызовов до тех пор, пока не будет завершен запрос к БД или пока воспроизведения запрещены</p>
  </li>
</ul>

<p>2. Переподключение<br />Эта фаза инициируется исправляемой ошибкой. Непрерывность работы приложения выполняет следующие задачи:</p>

<ul>
  <li>
    <p>Убеждается, что разрешено воспроизведение запросов к БД</p>
  </li>
  <li>
    <p>Управляет временем обработки запросов</p>
  </li>
  <li>
    <p>Получает новое подключение к БД, а затем проверяет, что это допустимый целевой объект БД</p>
  </li>
  <li>
    <p>Использует Transaction Guard для определения того, успешно ли была зафиксирована последняя транзакция (зафиксированные транзакции повторно не отправляются)</p>
  </li>
</ul>

<p>3. Повтор<br />Непрерывность работы приложения выполняет следующие задачи:</p>

<ul>
  <li>
    <p>Воспроизводит вызовы, которые находятся в очереди</p>
  </li>
  <li>
    <p>Отключает воспроизведение, если во время воспроизведения появляются видимые пользователем изменения в результатах</p>
  </li>
  <li>
    <p>Не разрешает фиксацию, но позволяет последнему вызову (который столкнулся с ошибкой) произвести коммит</p>
  </li>
</ul>

<p>После успешного воспроизведения запрос продолжается с момента сбоя.</p>

<h2 id="обзор-автономных-транзакций">Обзор автономных транзакций</h2>

<p><strong>Автономная транзакция</strong> – это независимая транзакция, которая может быть вызвана из другой транзакции, которая является основной транзакцией. Вы можете приостановить вызывающую транзакцию, выполнить операции SQL и зафиксировать или отменить их в автономной транзакции, а затем возобновить вызывающую транзакцию.</p>

<p>Автономные транзакции полезны для действий, которые должны выполняться независимо, независимо от того, фиксирует ли вызывающая транзакция или откатывает. Например, в транзакции покупки акций вы хотите зафиксировать данные клиента независимо от того, была ли произведена общая покупка акций. Кроме того, вы хотите записывать сообщения об ошибках в таблицу отладки, даже если общая транзакция откатывается.</p>

<p>Автономные транзакции обладают следующими характеристиками:</p>

<ul>
  <li>
    <p>Автономная транзакция не видит незафиксированных изменений, внесенных основной транзакцией, и не делится блокировками или ресурсами с основной транзакцией.</p>
  </li>
  <li>
    <p>Изменения в автономной транзакции видны другим транзакциям после фиксации автономных транзакций. Таким образом, пользователи могут получить доступ к обновленной информации, не дожидаясь фиксации основной транзакции.</p>
  </li>
  <li>
    <p>Автономные транзакции могут запускать другие автономные транзакции. Кроме ограничений на ресурсы, нет ограничений на то, сколько уровней автономных транзакций может быть вызвано.</p>
  </li>
</ul>

<p>В PL/SQL автономная транзакция выполняется в автономной области, которая представляет собой процедуру, помеченную <code class="language-plaintext highlighter-rouge">pragma AUTONOMOUS_TRANSACTION</code>. В этом контексте подпрограммы включают анонимные блоки PL/SQL верхнего уровня, а также подпрограммы и триггеры PL/SQL. Прагма – это директива, которая предписывает компилятору выполнить параметр компиляции. <code class="language-plaintext highlighter-rouge">Pragma AUTONOMOUS_TRANSACTION</code> сообщает БД, что эта процедура при выполнении должна выполняться как новая автономная транзакция, независимая от своей родительской транзакции.</p>

<p>На следующем рисунке показано, как управление переходит от основной процедуры (<code class="language-plaintext highlighter-rouge">MT</code>) к автономной процедуре и обратно. Основная процедура – <code class="language-plaintext highlighter-rouge">proc1</code>, а автономная процедура – <code class="language-plaintext highlighter-rouge">proc2</code>. Автономная процедура может совершить несколько транзакций (<code class="language-plaintext highlighter-rouge">AT1</code> и <code class="language-plaintext highlighter-rouge">AT2</code>), прежде чем управление вернется к основной процедуре.</p>

<p><strong>Рис 12-4. Поток управления транзакциями</strong></p>

<p><img src="/assets/images/oracon_fig12_4.jpg" alt="oracon_fig12_4" /></p>

<p>Когда вы входите в исполняемый раздел автономной процедуры, основная процедура приостанавливается. Когда вы выходите из автономной процедуры, основная процедура возобновляется.</p>

<p>На рисунке 12-4 <code class="language-plaintext highlighter-rouge">COMMIT</code> внутри <code class="language-plaintext highlighter-rouge">proc1</code> фиксирует не только свою собственную работу, но и любую незавершенную работу, выполненную в его сеансе. <code class="language-plaintext highlighter-rouge">COMMIT</code> внутри <code class="language-plaintext highlighter-rouge">proc2</code> делает постоянной только работу, выполненную в транзакции <code class="language-plaintext highlighter-rouge">proc2</code>. Таким образом, инструкции <code class="language-plaintext highlighter-rouge">COMMIT</code> в транзакциях <code class="language-plaintext highlighter-rouge">AT1</code> и <code class="language-plaintext highlighter-rouge">AT2</code> не оказывают никакого влияния на транзакцию <code class="language-plaintext highlighter-rouge">MT</code>.</p>

<h2 id="обзор-распределенных-транзакций">Обзор распределенных транзакций</h2>

<p><strong>Распределенная транзакция</strong> – это транзакция, которая включает в себя одну или несколько инструкций, которые обновляют данные на двух или более различных узлах распределенной БД, используя объект схемы, называемый DBLink.</p>

<p><strong>Распределенная БД</strong> - это набор БД в распределенной системе, которые могут отображаться приложениями как единый источник данных. DBLink описывает, как один экземпляр БД может войти в другой экземпляр БД.</p>

<p>В отличие от транзакции в локальной БД, распределенная транзакция изменяет данные в нескольких БД. Следовательно, распределенная обработка транзакций является более сложной, поскольку БД должна координировать фиксацию или откат изменений в транзакции как атомарной единице. Вся транзакция должна быть зафиксирована или откатана. БД Oracle должна координировать управление транзакциями по сети и поддерживать согласованность данных, даже если происходит сетевой или системный сбой.</p>

<h3 id="двух-фазный-commit">Двух-фазный COMMIT</h3>

<p>Двухфазный механизм фиксации гарантирует, что все частичные БД, участвующие в распределенной транзакции, либо все фиксируют, либо все отменяют инструкции в транзакции. Этот механизм также защищает неявный DML выполняемый ограничениями целостности, удаленными вызовами процедур и триггерами.</p>

<p>При двухфазной фиксации между несколькими БД одна база данных координирует распределенную транзакцию. Инициирующий узел называется глобальным координатором. Координатор запрашивает другие БД, готовы ли они к фиксации. Если какая-либо БД отвечает “нет”, то вся транзакция откатывается. Если все БД проголосуют “за”, то координатор отправит сообщение, чтобы сделать фиксацию постоянной в каждой из БД.</p>

<p>Двухэтапный механизм фиксации прозрачен для пользователей, которые осуществляют распределенные транзакции. Фактически, пользователям даже не нужно знать, что транзакция распределена. Оператор COMMIT, обозначающий завершение транзакции, автоматически запускает механизм двухфазной фиксации. Для включения распределенных транзакций в тело приложения БД не требуется никакого кодирования или сложного синтаксиса инструкций.</p>

<h3 id="сомнительные-транзакции">Сомнительные транзакции</h3>

<p>Сомнительная распределенная транзакция возникает, когда двухфазная фиксация была прервана каким-либо системным или сетевым сбоем.</p>

<p>Например, две БД сообщают координирующей БД, что они были готовы к фиксации, но экземпляр координирующей БД завершает работу с ошибкой сразу после получения сообщений. Две БД, которые готовы к фиксации, теперь остаются зависшими, ожидая уведомления о результатах.</p>

<p>Фоновый процесс recoverer (RECO) автоматически разрешает результаты сомнительных распределенных транзакций. После устранения сбоя и восстановления связи процесс RECO каждой локальной БД Oracle автоматически фиксирует или откатывает любые сомнительные распределенные транзакции последовательно на всех задействованных узлах.</p>

<p>В случае длительного сбоя Oracle Database позволяет каждому локальному администратору вручную зафиксировать или отменить любые распределенные транзакции, которые вызывают сомнения из-за сбоя. Этот параметр позволяет администратору локальной базы данных освободить все заблокированные ресурсы, которые хранятся неопределенно долго из-за длительного сбоя.</p>

<p>Если БД должна быть восстановлена до прошлого времени, то средства восстановления БД позволяют администраторам БД на других сайтах возвращать свои базы данных к более раннему моменту времени. Эта операция гарантирует, что глобальная база данных остается согласованной.</p>

<p><br /><br /><br /><br /><br /><br /><br /></p>
<div class="row">
  <div class="col"><div align="left"><a href="/pages/skills/oracle/concept/11concurrency.html">&#8592; 11. Параллелизм и согласованность данных (Data Concurrency and Consistency)</a></div>
  </div>
  <div class="col"><div align="right"><a href="/pages/skills/oracle/concept/13physical.html">13. Физические структуры хранения. &#8594;</a></div> 
 </div> 
</div>

   	</div>
</div></section>

    <footer class="footer hexlet-footer py-5 mt-5 text-muted">
  <div class="container">
    <div class="row mt-1">
      <div class="col-12 text-center">
        <a href="https://aveligzhanin.github.io/">Велигжанин Андрей</a> — Программист-разработчик C++ и Oracle.
      </div>
    </div>
  </div>
</footer>

  </body>
</html>