<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Партиции, Представления, и Другие Объекты Схемы</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- Our style -->
    <link rel="stylesheet" type="text/css" href="/assets/css/styles.css">
	<link rel="stylesheet" type="text/css" href="/assets/css/avel.css">
</head>

  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light navbar-fixed-top">
  <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Сайт Велигжанина Андрея</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse menu">
			<ul class="nav navbar-nav navbar-right">
                 
                    <li>
                       <a href="/index.html#about">Обо мне</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#education">Образование</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#work">Работа</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#skills">Навыки</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#portfolio">Портфолио</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#hobby">Увлечения</a>
                    </li>
                 
                    <li>
                       <a href="/index.html#contact">Контакты</a>
                    </li>
                 
        	</ul>
        </div>
      </div>
  </div>
</nav>

    <section class="pfblock"><div class="container">  		<!-- Translations -->
	<div class="col-xs-6" align=left>
		<a href="/index.html">home</a> \ <a href="/pages/skills/oracle/concepts.html">Oracle. Database Concepts</a>
	</div>

	<div class="col-xs-6" align=right>
		Написано: 04.04.2023
	</div>

   	<div class="col-sm-12 my">
		<h1 id="6-партиции-представления-и-другие-объекты-схемы"><a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/partitions-views-and-other-schema-objects.html#GUID-3E154566-50D6-48C1-BAE5-57EF20266B43">6. Партиции, Представления, и Другие Объекты Схемы</a></h1>

<p>Хотя таблицы и индексы являются наиболее важными и часто используемыми объектами схемы, база данных поддерживает множество других типов объектов схемы, наиболее распространенные из которых обсуждаются в этой главе.</p>

<h2 id="обзор-партиционирования">Обзор партиционирования</h2>

<p>В БД Oracle <strong>партиционирование</strong> позволяет разбивать очень большие таблицы и индексы на более мелкие и управляемые части, называемые партициями. Каждая партиция представляет собой независимый объект со своим собственным именем и, возможно, собственными характеристиками хранилища.</p>

<p>Для аналогии, иллюстрирующей партиционирование, предположим, что у менеджера по персоналу есть один большой ящик, содержащий папки сотрудников. В каждой папке указана дата найма сотрудника. Запросы часто делаются по сотрудникам, нанятым в определенном месяце. Одним из подходов к удовлетворению таких запросов является создание индекса по дате найма сотрудника, который указывает расположение папок, разбросанных по всему ящику. В отличие от этого, стратегия партиционирования использует множество ячеек меньшего размера, причем каждая ячейка содержит папки для сотрудников, нанятых в данном месяце.</p>

<p>Использование коробок меньшего размера имеет ряд преимуществ. Когда менеджера по персоналу попросят получить папки для сотрудников, принятых на работу в июне, он может просто взять июньский ящик. Кроме того, если какая-либо маленькая коробка временно повреждена, другие маленькие коробки остаются доступными. Перемещение офисов также становится проще, потому что вместо перемещения одной тяжелой коробки менеджер может переместить несколько небольших коробок.</p>

<p>С точки зрения приложения существует только один объект схемы. Инструкции SQL не требуют никаких изменений для доступа к партиционированным таблицам. Партиционирование полезно для многих различных типов приложений БД, особенно для тех, которые управляют большими объемами данных.</p>

<p>Преимущества заключаются в следующем:</p>

<ul>
  <li>
    <p><strong>В повышении доступности</strong><br />Недоступность партиции не влечет за собой недоступность объекта. Оптимизатор запросов автоматически удаляет партиции, на которые нет ссылок, из плана запросов, чтобы на запросы не влияли, когда партиции недоступны.</p>
  </li>
  <li>
    <p><strong>В упрощении администрирования объектов схемы</strong><br />Партиционированный объект состоит из частей, которыми можно управлять как коллективно, так и по отдельности. Инструкции DDL могут управлять партициями, а не целыми таблицами или индексами. Таким образом, вы можете разбить ресурсоемкие задачи, такие как перестройка индекса или таблицы. Например, вы можете перемещать по одной партиции таблицы за раз. Если возникает проблема, то необходимо повторить только перемещение партиции, а не перемещение таблицы. Кроме того, удаление партиции позволяет избежать выполнения многочисленных инструкций DELETE.</p>
  </li>
  <li>
    <p><strong>В уменьшении конкуренции за общие ресурсы в системах OLTP</strong><br />В некоторых системах OLTP партиции могут уменьшить конкуренцию за общий ресурс. Например, DML распределен по многим сегментам, а не по одному сегменту.</p>
  </li>
  <li>
    <p><strong>В повышеннии производительности в запросах для хранилищ данных</strong><br />В хранилище данных партиционирование может ускорить обработку специальных запросов. Например, таблицу продаж, содержащую миллион строк, можно разделить по кварталам.</p>
  </li>
</ul>

<h3 id="характеристики-партиции">Характеристики партиции</h3>

<p>Каждая партиция таблицы или индекса должна иметь одинаковые логические атрибуты, такие как имена столбцов, типы данных и ограничения. Например, все партиции таблицы используют одни и те же определения столбцов и ограничений.</p>

<p>Однако каждая партиция может иметь отдельные физические атрибуты, такие как табличное пространство, к которому она принадлежит.</p>

<h4 id="ключ-партиции"><strong>Ключ партиции</strong></h4>

<p>Ключ партиции – это набор из одного или нескольких столбцов, который определяет партицию, в которую должна входить каждая строка в партиционированной таблице. Каждая строка однозначно назначается одной партиции.</p>

<p>В таблице <code class="language-plaintext highlighter-rouge">sales</code> (продажи) вы могли бы указать столбец <code class="language-plaintext highlighter-rouge">time_id</code> в качестве ключа партиции диапазона. БД присваивает строки партициям в зависимости от того, попадает ли дата в этом столбце в указанный диапазон. БД Oracle автоматически направляет операции вставки, обновления и удаления в соответствующую партицию с помощью ключа партиции.</p>

<h4 id="стратегии-партиционирования"><strong>Стратегии партиционирования</strong></h4>

<p>Oracle предлагает несколько стратегий партиционирования, которые управляют тем, как БД размещает данные в партициях. Основными стратегиями являются разделение по диапазону, списку и хэшу.</p>

<p><strong>Одноуровневое партиционирование</strong> использует только один метод распределения данных, например, разбиение только на списки или только на диапазоны. При составном партиционировании таблица разбивается на партиции с помощью одного метода распределения данных, а затем каждая партиция дополнительно делится на подпартиции с использованием второго метода распределения данных. Например, вы могли бы использовать списочное партиционирование для <code class="language-plaintext highlighter-rouge">channel_id</code> и диапазонное партиционирование для <code class="language-plaintext highlighter-rouge">time_id</code>.</p>

<p><strong>Пример 6-1 Пример набора строк для секционированной таблицы</strong></p>

<p>В этом примере партиционирования предполагается, что вы хотите заполнить партиционированную таблицу <code class="language-plaintext highlighter-rouge">sales</code> следующими строками:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  PROD_ID    CUST_ID TIME_ID   CHANNEL_ID   PROMO_ID QUANTITY_SOLD AMOUNT_SOLD
---------- ---------- --------- ---------- ---------- ------------- -----------
      116      11393 05-JUN-99          2        999             1       12.18
       40     100530 30-NOV-98          9         33             1       44.99
      118        133 06-JUN-01          2        999             1       17.12
      133       9450 01-DEC-00          2        999             1       31.28
       36       4523 27-JAN-99          3        999             1       53.89
      125       9417 04-FEB-98          3        999             1       16.86
       30        170 23-FEB-01          2        999             1         8.8
       24      11899 26-JUN-99          4        999             1       43.04
       35       2606 17-FEB-00          3        999             1       54.94
       45       9491 28-AUG-98          4        350             1       47.45 
</code></pre></div></div>

<h5 id="диапазонное-партиционирование-range"><strong>Диапазонное партиционирование (Range)</strong></h5>

<p>При диапазонном партиционировании БД сопоставляет партиционируемые строки на основании диапазона значений ключа партиционирования. Диапазонное партиционирование является наиболее распространенным типом партиционирования и часто используется с датами.</p>

<p>Предположим, что вы создаете <code class="language-plaintext highlighter-rouge">time_range_sales</code> в виде партиционированной таблицы, используя следующую инструкцию SQL, со столбцом <code class="language-plaintext highlighter-rouge">time_id</code> в качестве ключа партиционирования:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">time_range_sales</span>
   <span class="p">(</span> <span class="n">prod_id</span>        <span class="n">NUMBER</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
   <span class="p">,</span> <span class="n">cust_id</span>        <span class="n">NUMBER</span>
   <span class="p">,</span> <span class="n">time_id</span>        <span class="nb">DATE</span>
   <span class="p">,</span> <span class="n">channel_id</span>     <span class="nb">CHAR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
   <span class="p">,</span> <span class="n">promo_id</span>       <span class="n">NUMBER</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
   <span class="p">,</span> <span class="n">quantity_sold</span>  <span class="n">NUMBER</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="p">,</span> <span class="n">amount_sold</span>    <span class="n">NUMBER</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
   <span class="p">)</span>
<span class="k">PARTITION</span> <span class="k">BY</span> <span class="k">RANGE</span> <span class="p">(</span><span class="n">time_id</span><span class="p">)</span>
 <span class="p">(</span><span class="k">PARTITION</span> <span class="n">SALES_1998</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="n">TO_DATE</span><span class="p">(</span><span class="s1">'01-JAN-1999'</span><span class="p">,</span><span class="s1">'DD-MON-YYYY'</span><span class="p">)),</span>
  <span class="k">PARTITION</span> <span class="n">SALES_1999</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="n">TO_DATE</span><span class="p">(</span><span class="s1">'01-JAN-2000'</span><span class="p">,</span><span class="s1">'DD-MON-YYYY'</span><span class="p">)),</span>
  <span class="k">PARTITION</span> <span class="n">SALES_2000</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="n">TO_DATE</span><span class="p">(</span><span class="s1">'01-JAN-2001'</span><span class="p">,</span><span class="s1">'DD-MON-YYYY'</span><span class="p">)),</span>
  <span class="k">PARTITION</span> <span class="n">SALES_2001</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="k">MAXVALUE</span><span class="p">)</span>
 <span class="p">);</span> 
</code></pre></div></div>

<p>После этого вы загружаете <code class="language-plaintext highlighter-rouge">time_range_sales</code> со строками из <strong>примера 6-1</strong>. Код показывает распределение строк по четырем партициям. БД выбирает партицию для каждой строки на основе значения <code class="language-plaintext highlighter-rouge">time_id</code> в соответствии с правилами, указанными в предложении <code class="language-plaintext highlighter-rouge">PARTITION BY RANGE</code>. Значение ключа партиционирования диапазона определяет не включающую верхнюю границу для указанной партиции.</p>

<h5 id="интервальное-партиционирование-interval"><strong>Интервальное партиционирование (Interval)</strong></h5>

<p><strong>Интервальное партиционирование</strong> – является расширением диапазонного.</p>

<p>Если вы вставляете данные, которые превышают существующие партиции диапазона, то БД Oracle автоматически создает партиции с указанным интервалом. Например, вы могли бы создать таблицу истории продаж, в которой данные за каждый месяц хранятся в отдельной партиции.</p>

<p>Интервальное партиционирование позволяет избежать явного создания интервальных партиций. Можно использовать интервальное партиционирование практически для каждой таблицы, которая партиционирована по диапазонам и использует фиксированные интервалы для новых партиций. Если вы не создаете диапазонные партиции с разными интервалами или если вы всегда не задаете определенные атрибуты партиций, рассмотрите возможность использования интервальных партиций.</p>

<p>При интервальном партиционировании необходимо указать хотя бы одну партицию диапазона. Значение ключа партиционирования диапазона определяет максимальное значение партиции диапазона, которое называется <strong>точкой перехода</strong>. БД автоматически создает интервальные партиции для данных со значениями, которые находятся за пределами точки перехода. Нижняя граница каждого интервального партиционирования является включающей верхней границей предыдущего диапазона или интервальной партиции. Таким образом, в примере 6-2 значение 01-JAN-2011 находится в партиции <code class="language-plaintext highlighter-rouge">p2</code>.</p>

<p>БД создает интервальные партиции для данных за пределами точки перехода. Интервальное партиционирование расширяет партиционирование по диапазонам, предоставляя БД указание создавать партиции с указанным диапазоном или интервалом. БД автоматически создает партиции, когда данные, вставленные в таблицу, превышают все существующие партиции диапазона. В примере 6-2 раздел <code class="language-plaintext highlighter-rouge">p3</code> содержит строки со значениями <code class="language-plaintext highlighter-rouge">time_id</code> ключа партиции, большими или равными 01-JAN-2013.</p>

<p><strong>Пример 6-2 Интервальное партиционирование</strong></p>

<p>Предположим, что вы создаете таблицу продаж с четырьмя партициями разной ширины. Вы указываете, что выше точки перехода <code class="language-plaintext highlighter-rouge">1 января 2013</code> года БД должна создавать партиции с интервалом в один месяц. Верхняя граница партиции <code class="language-plaintext highlighter-rouge">p3</code> представляет собой точку перехода. Партиция <code class="language-plaintext highlighter-rouge">p3</code> и все партиции под ней находятся в партициях диапазона, тогда как все партиции над ней попадают в партиции интервала.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">interval_sales</span>
    <span class="p">(</span> <span class="n">prod_id</span>        <span class="n">NUMBER</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">cust_id</span>        <span class="n">NUMBER</span>
    <span class="p">,</span> <span class="n">time_id</span>        <span class="nb">DATE</span>
    <span class="p">,</span> <span class="n">channel_id</span>     <span class="nb">CHAR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">promo_id</span>       <span class="n">NUMBER</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">quantity_sold</span>  <span class="n">NUMBER</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">amount_sold</span>    <span class="n">NUMBER</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span> 
  <span class="k">PARTITION</span> <span class="k">BY</span> <span class="k">RANGE</span> <span class="p">(</span><span class="n">time_id</span><span class="p">)</span> 
  <span class="n">INTERVAL</span><span class="p">(</span><span class="n">NUMTOYMINTERVAL</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'MONTH'</span><span class="p">))</span>
    <span class="p">(</span> <span class="k">PARTITION</span> <span class="n">p0</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="n">TO_DATE</span><span class="p">(</span><span class="s1">'1-1-2010'</span><span class="p">,</span> <span class="s1">'DD-MM-YYYY'</span><span class="p">))</span>
    <span class="p">,</span> <span class="k">PARTITION</span> <span class="n">p1</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="n">TO_DATE</span><span class="p">(</span><span class="s1">'1-1-2011'</span><span class="p">,</span> <span class="s1">'DD-MM-YYYY'</span><span class="p">))</span>
    <span class="p">,</span> <span class="k">PARTITION</span> <span class="n">p2</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="n">TO_DATE</span><span class="p">(</span><span class="s1">'1-7-2012'</span><span class="p">,</span> <span class="s1">'DD-MM-YYYY'</span><span class="p">))</span>
    <span class="p">,</span> <span class="k">PARTITION</span> <span class="n">p3</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="n">TO_DATE</span><span class="p">(</span><span class="s1">'1-1-2013'</span><span class="p">,</span> <span class="s1">'DD-MM-YYYY'</span><span class="p">))</span> <span class="p">);</span>
</code></pre></div></div>

<p>Вы добавляете продажу, совершенную <code class="language-plaintext highlighter-rouge">10 октября 2014 года</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SQL&gt; INSERT INTO interval_sales VALUES (39,7602,'10-OCT-14',9,null,1,11.79);

1 row created.
</code></pre></div></div>

<p>Запрос <code class="language-plaintext highlighter-rouge">USER_TAB_PARTITIONS</code> показывает, что БД создала новую партицию для продажи 10 октября, поскольку дата продажи была позже точки перехода:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SQL&gt; COL PNAME FORMAT a9
SQL&gt; COL HIGH_VALUE FORMAT a40
SQL&gt; SELECT PARTITION_NAME AS PNAME, HIGH_VALUE 
  2  FROM USER_TAB_PARTITIONS WHERE TABLE_NAME = 'INTERVAL_SALES';

PNAME     HIGH_VALUE
--------- ----------------------------------------
P0        TO_DATE(' 2007-01-01 00:00:00', 'SYYYY-M
          M-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
P1        TO_DATE(' 2008-01-01 00:00:00', 'SYYYY-M
          M-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
P2        TO_DATE(' 2009-07-01 00:00:00', 'SYYYY-M
          M-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
P3        TO_DATE(' 2010-01-01 00:00:00', 'SYYYY-M
          M-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
SYS_P1598 TO_DATE(' 2014-11-01 00:00:00', 'SYYYY-M
          M-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA
</code></pre></div></div>

<h5 id="списочное-партиционирование-list"><strong>Списочное партиционирование (List)</strong></h5>

<p>При списочном партиционировании БД использует список дискретных значений в качестве ключа партиционирования для каждой партиции. Ключ партиционирования состоит из одного или нескольких столбцов.</p>

<p>Можно использовать списочное партиционирование, чтобы управлять тем, как отдельные строки соотносятся с определенными партициями. Используя списки, можно группировать и упорядочивать связанные наборы данных, когда ключ, используемый для их идентификации, не упорядочен удобным образом.</p>

<p><strong>Пример 6-3 Списочное партиционирование</strong></p>

<p>Предположим, что вы создаете <code class="language-plaintext highlighter-rouge">list_sales</code> в виде таблицы со списочным партиционированием, используя следующий оператор, где столбец <code class="language-plaintext highlighter-rouge">channel_id</code> является ключом партиции:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE list_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY LIST (channel_id)
 ( PARTITION even_channels VALUES ('2','4'),
   PARTITION odd_channels VALUES ('3','9')
 ); 
</code></pre></div></div>

<p>После этого вы загружаете таблицу со строками из примера 6-1. Код показывает распределение строк в двух партициях. БД выбирает партицию для каждой строки на основе значения <code class="language-plaintext highlighter-rouge">channel_id</code> в соответствии с правилами, указанными в предложении <code class="language-plaintext highlighter-rouge">PARTITION BY LIST</code>. Строки со значением <code class="language-plaintext highlighter-rouge">channel_id</code>, равным <code class="language-plaintext highlighter-rouge">2</code> или <code class="language-plaintext highlighter-rouge">4</code>, хранятся в партиции <code class="language-plaintext highlighter-rouge">EVEN_CHANNELS</code>, в то время как строки со значением <code class="language-plaintext highlighter-rouge">channel_id</code>, равным <code class="language-plaintext highlighter-rouge">3</code> или <code class="language-plaintext highlighter-rouge">9</code>, хранятся в партиции <code class="language-plaintext highlighter-rouge">ODD_CHANNELS</code>.</p>

<h5 id="хэшированное-партиционирование-hash"><strong>Хэшированное партиционирование (Hash)</strong></h5>

<p>При хэш-партиционировании БД сопоставляет строки с партициями на основе алгоритма хэширования, который БД применяет к указанному пользователем ключу партиционирования.</p>

<p>Назначение строки определяется внутренней хэш-функцией, применяемой к строке базой данных. Когда количество разделов равно степени 2, алгоритм хеширования создает примерно равномерное распределение строк по всем партициям.</p>

<p>Хэш-партиционирование полезно для разделения больших таблиц для повышения управляемости. Вместо одной большого таблицы, которой нужно управлять, у вас есть несколько частей поменьше. Потеря одной хэш-партиции не влияет на остальные партиции и может быть восстановлена независимо. Хэш-партиционирование также полезно в системах OLTP с высокой конкуренцией за обновления. Например, сегмент разделен на несколько частей, каждая из которых обновляется, вместо одного сегмента, который испытывает конфликт.</p>

<p>Предположим, что вы создаете партиционированную таблицу <code class="language-plaintext highlighter-rouge">hash_sales</code>, используя следующий оператор, со столбцом <code class="language-plaintext highlighter-rouge">prod_id</code> в качестве ключа партиционирования:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE hash_sales
   ( prod_id        NUMBER(6)
   , cust_id        NUMBER
   , time_id        DATE
   , channel_id     CHAR(1)
   , promo_id       NUMBER(6)
   , quantity_sold  NUMBER(3)
   , amount_sold    NUMBER(10,2)
   )
PARTITION BY HASH (prod_id)
PARTITIONS 2; 
</code></pre></div></div>

<p>После этого вы загружаете таблицу со строками из примера 6-1. Код показывает возможное распределение строк в двух партициях. Имена этих партиций генерируются системно.</p>

<p>Когда вы вставляете строки, БД пытается случайным образом и равномерно распределить их по партициям. Вы не можете указать партицию, в которую помещается строка. БД применяет хэш-функцию, результат которой определяет, какая партиция содержит строку.</p>

<h5 id="ссылочное-партиционирование-reference"><strong>Ссылочное партиционирование (Reference)</strong></h5>

<p>При ссылочном партиционировании стратегия партиционирования дочерней таблицы определяется исключительно через связь внешнего ключа с родительской таблицей. Для каждой партиции в родительской таблице в дочерней таблице существует ровно одна соответствующая партиция. Родительская таблица хранит родительские записи в определенной партиции, а дочерняя таблица хранит дочерние записи в соответствующей партиции.</p>

<p>Например, таблица <code class="language-plaintext highlighter-rouge">orders</code> является родительской для таблицы <code class="language-plaintext highlighter-rouge">line_items</code>, с первичным ключом и внешним ключом, определенными для <code class="language-plaintext highlighter-rouge">order_id</code>. Таблицы партиционированы ссылочно. Например, если БД хранит заказ <code class="language-plaintext highlighter-rouge">233</code> в партиции <code class="language-plaintext highlighter-rouge">Q3_2015</code> таблицы <code class="language-plaintext highlighter-rouge">orders</code>, то БД хранит все позиции для заказа <code class="language-plaintext highlighter-rouge">233</code> в партиции <code class="language-plaintext highlighter-rouge">Q3_2015</code> для <code class="language-plaintext highlighter-rouge">line_items</code>. Если партиция <code class="language-plaintext highlighter-rouge">Q4_2015</code> добавлена в таблице <code class="language-plaintext highlighter-rouge">orders</code>, то БД автоматически добавляет <code class="language-plaintext highlighter-rouge">Q4_2015</code> в таблице <code class="language-plaintext highlighter-rouge">line_items</code>.</p>

<p>Преимуществами ссылочного партиционирования являются:</p>

<ul>
  <li>
    <p>Используя одну и ту же стратегию партиционирования как для родительской, так и для дочерней таблиц, вы избегаете дублирования всех ключевых столбцов партиционирования. Эта стратегия уменьшает накладные расходы, связанные с денормализацией вручную, и экономит место.</p>
  </li>
  <li>
    <p>Операции обслуживания родительской таблицы выполняются в дочерней таблице автоматически. Например, когда вы добавляете партицию в главную таблицу, БД автоматически распространяет это добавление на своих потомков.</p>
  </li>
  <li>
    <p>БД автоматически использует разумное соединение партиций родительской и дочерней таблиц, что повышает производительность.</p>
  </li>
</ul>

<p>Вы можете использовать ссылочное партиционирование со всеми базовыми стратегиями партиционирования, включая интервальное. Также можно создавать ссылочные партиционированные таблицы в виде составных партиций.</p>

<p><strong>Пример 6-4 Создание ссылочно-партиционированных таблиц</strong></p>

<p>В этом примере создается родительская таблица <code class="language-plaintext highlighter-rouge">orders</code>, диапазонно-партиционированная по <code class="language-plaintext highlighter-rouge">order_date</code>. Ссылочно-партиционированная дочерняя таблица <code class="language-plaintext highlighter-rouge">order_items</code>, создается с четырьмя партициями, <code class="language-plaintext highlighter-rouge">Q1_2015</code>, <code class="language-plaintext highlighter-rouge">Q2_2015</code>, <code class="language-plaintext highlighter-rouge">Q3_2015</code> и <code class="language-plaintext highlighter-rouge">Q4_2015</code>, где каждая партиция содержит строки <code class="language-plaintext highlighter-rouge">order_items</code>, соответствующие заказам в соответствующих родительских партициях.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE orders
    ( order_id           NUMBER(12),
      order_date         DATE,
      order_mode         VARCHAR2(8),
      customer_id        NUMBER(6),
      order_status       NUMBER(2),
      order_total        NUMBER(8,2),
      sales_rep_id       NUMBER(6),
      promotion_id       NUMBER(6),
      CONSTRAINT orders_pk PRIMARY KEY(order_id)
    )
  PARTITION BY RANGE(order_date)
    ( PARTITION Q1_2015 VALUES LESS THAN (TO_DATE('01-APR-2015','DD-MON-YYYY')),
      PARTITION Q2_2015 VALUES LESS THAN (TO_DATE('01-JUL-2015','DD-MON-YYYY')),
      PARTITION Q3_2015 VALUES LESS THAN (TO_DATE('01-OCT-2015','DD-MON-YYYY')),
      PARTITION Q4_2015 VALUES LESS THAN (TO_DATE('01-JAN-2006','DD-MON-YYYY'))
    );

CREATE TABLE order_items
    ( order_id           NUMBER(12) NOT NULL,
      line_item_id       NUMBER(3)  NOT NULL,
      product_id         NUMBER(6)  NOT NULL,
      unit_price         NUMBER(8,2),
      quantity           NUMBER(8),
      CONSTRAINT order_items_fk
      FOREIGN KEY(order_id) REFERENCES orders(order_id)
    )
    PARTITION BY REFERENCE(order_items_fk);
</code></pre></div></div>

<h5 id="составное-партиционирование-composite"><strong>Составное партиционирование (Composite)</strong></h5>

<p>При составном партиционировании таблица разбивается на партиции с помощью одного метода распределения данных, а затем каждая партиция дополнительно подразделяется на подпартиции с использованием второго метода распределения данных. Таким образом, составное партиционирование сочетает в себе основные методы распределения данных. Все подпартиции для данной партиции представляют собой логическое подмножество данных.</p>

<p>Составное партиционирование обеспечивает ряд преимуществ:</p>

<ul>
  <li>
    <p>В зависимости от инструкции SQL сокращение партиции по одному или двум измерениям может повысить производительность.</p>
  </li>
  <li>
    <p>Запросы могут иметь возможность использовать полные или частичные объединения партиций в любом измерении.</p>
  </li>
  <li>
    <p>Можно выполнять параллельное резервное копирование и восстановление одной таблицы.</p>
  </li>
  <li>
    <p>Количество секций больше, чем при одноуровневом партиционировании, что может быть выгодно для параллельного выполнения.</p>
  </li>
  <li>
    <p>Можно реализовать скользящее окно для поддержки исторических данных и по-прежнему разбивать на партиции в другом измерении, если многие инструкции могут извлечь выгоду из сокращения партиций или соединения партиций.</p>
  </li>
  <li>
    <p>Можно хранить данные по-разному, основываясь на идентификации с помощью ключа партиционоривания. Например, вы можете принять решение сохранить данные для определенного типа продукта в сжатом формате, доступном только для чтения, и сохранить данные о других типах продуктов несжатыми.</p>
  </li>
</ul>

<p>Разбиение на диапазоны, списки и хэш-функции допустимо в качестве стратегий партиционирования на подпартиции для составных партиционированных таблиц. На следующем рисунке представлено графическое представление составных партиций range-hash и range-list.</p>

<p><img src="/assets/images/oracon_fig6_1.jpg" alt="OraCon_Fig6_1" /></p>

<p>БД хранит каждую подпартицию в составной партиционированной таблице в виде отдельного сегмента. Таким образом, свойства подпартиций могут отличаться от свойств таблицы или партиций, к которому принадлежат подпартиции.</p>

<h3 id="партиционированные-таблицы">Партиционированные таблицы</h3>

<p><strong>Партиционированная таблица</strong> состоит из одной или нескольких партиций, которые управляются индивидуально и могут работать независимо от других партиций.</p>

<p>Таблица может быть либо партиционированной, либо непартиционированной. Даже если партиционированная таблица состоит только из одной партиции, эта таблица отличается от непартиционированной таблицы без разделов, к которой нельзя добавлять партиции.</p>

<h4 id="сегменты-партиционированной-таблицы"><strong>Сегменты партиционированной таблицы</strong></h4>

<p>Партиционированная таблица состоит из одного или нескольких сегментов табличной партиции.</p>

<p>Если вы создаете партиционированную таблицу с именем <code class="language-plaintext highlighter-rouge">hash_products</code>, для этой таблицы не выделяется табличный сегмент. Вместо этого БД сохраняет данные каждой табличной партиции в своем собственном сегменте партиции. Каждый сегмент табличной партиции содержит часть табличных данных.</p>

<p>Когда партиционирована <strong>внешняя таблица</strong>, все партиции находятся вне БД. В гибридной партиционированной таблице некоторые партиции хранятся в виде сегментов, в то время как другие хранятся извне. Например, некоторые партиции таблицы продаж могут храниться в файлах данных, а другие – в электронных таблицах.</p>

<h4 id="сжатие-партиционированных-таблиц"><strong>Сжатие партиционированных таблиц</strong></h4>

<p>Некоторые или все разделы таблицы, организованной в куче, можно сохранять в сжатом формате.</p>

<p>Сжатие экономит место и может ускорить выполнение запроса. По этой причине сжатие может быть полезно в таких средах, как хранилища данных, где объем операций вставки и обновления невелик, а также в средах OLTP.</p>

<p>Можно объявить атрибуты сжатия для табличного пространства, таблицы или партиции. Если сжатие объявлено на уровне табличного пространства, то таблицы, созданные в табличном пространстве, сжимаются по умолчанию. Можно изменить атрибут сжатия для таблицы, и в этом случае изменение применяется только к новым данным, поступающим в эту таблицу. Следовательно, одна таблица или партиция могут содержать сжатые и несжатые блоки, что гарантирует, что размер данных не увеличится из-за сжатия. Если сжатие может увеличить размер блока, то БД не применяет его к блоку.</p>

<h3 id="партиционированные-индексы">Партиционированные индексы</h3>

<p><strong>Партиционированный индекс</strong> – это индекс, который, подобно партиционированной таблице, был разделен на более мелкие и управляемые части.</p>

<p>Глобальные индексы разбиваются на партиции, независимо от таблицы, для которой они созданы, в то время как локальные индексы автоматически привязываются к методу разбиения таблицы на партиции. Подобно партиционированным таблицам, партиционированные индексы улучшают управляемость, доступность, производительность и масштабируемость.</p>

<p>На следующем рисунке показаны параметры партиционированния индекса.</p>

<p><img src="/assets/images/oracon_fig6_2.jpg" alt="OraCon_Fig6_2" /></p>

<h4 id="локальные-партиционированные-индексы"><strong>Локальные партиционированные индексы</strong></h4>

<p>В <strong>локальном партиционированном индексе</strong> индекс разбит на те же столбцы, с тем же количеством партиций и теми же границами партиций, что и его таблица.</p>

<p>Каждая индексная партиция связана ровно с одной партицией базовой таблицы, так что все ключи индексной партиции относятся только к строкам, хранящимся в одной табличной партиции. Таким образом, БД автоматически синхронизирует индексные партиции со связанными с ними табличными партициями, делая каждую пару таблица-индекс независимой.</p>

<p>Локальные партиционированные индексы широко распространены в средах хранилищ данных. Локальные индексы обладают следующими преимуществами:</p>

<ul>
  <li>
    <p>Повышается доступность, поскольку действия, которые приводят к недействительности или недоступности данных в партиции, влияют только на эту партицию.</p>
  </li>
  <li>
    <p>Упрощается обслуживание партиций. При перемещении табличной партиции или при устаревании данных партиции необходимо перестраивать или поддерживать только связанную с ней локальную индексную партицию. В глобальном индексе все индексные партиции должны быть перестроены или поддерживаться в рабочем состоянии.</p>
  </li>
  <li>
    <p>Если происходит восстановление партиции на определенный момент времени, то индексы могут быть восстановлены до времени восстановления (см. Руководство пользователя Oracle Database Backup and Recovery). Весь индекс не нужно перестраивать заново.</p>
  </li>
</ul>

<p>В примере с хэш-партиционированием показана инструкция создания для партиционированной таблицы <code class="language-plaintext highlighter-rouge">hash_sales</code>, использующая столбец <code class="language-plaintext highlighter-rouge">prod_id</code> в качестве ключа партиционирования. В следующем примере создается локальный партиционированный индекс по столбцу <code class="language-plaintext highlighter-rouge">time_id</code> таблицы <code class="language-plaintext highlighter-rouge">hash_sales</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE INDEX hash_sales_idx ON hash_sales(time_id) LOCAL;
</code></pre></div></div>

<p>На рисунке 6-3 таблица <code class="language-plaintext highlighter-rouge">hash_products</code> имеет два партиции, поэтому и <code class="language-plaintext highlighter-rouge">hash_sales_index</code> имеет две партиции. Каждая индексная партиция связана с другой табличной партицией. Индексная партиция <code class="language-plaintext highlighter-rouge">SYS_P38</code> индексирует строки в табличной партиции <code class="language-plaintext highlighter-rouge">SYS_P33</code>, тогда как индексная партиция <code class="language-plaintext highlighter-rouge">SYS_P39</code> индексирует строки в табличной партиции <code class="language-plaintext highlighter-rouge">SYS_P34</code>.</p>

<p><img src="/assets/images/oracon_fig6_3.jpg" alt="OraCon_Fig6_3" /></p>

<p>Вы не можете добавить партицию в локальный индекс явно. Вместо этого новые партиции добавляются в локальные индексы только тогда, когда вы добавляете партицию в базовую таблицу. Аналогично, вы не можете явно удалить партицию из локального индекса. Вместо этого локальные индексные партиции удаляются только тогда, когда вы удаляете партицию из базовой таблицы.</p>

<p>Как и другие индексы, для партиционированных таблиц можно создать растровый индекс. Единственное ограничение заключается в том, что растровые индексы для партиционированной таблицы должны быть локальными – они не могут быть глобальными индексами. Глобальные растровые индексы поддерживаются только в непартиционированных таблицах.</p>

<h5 id="локальные-префиксные-и-непрефиксные-индексы"><strong>Локальные префиксные и непрефиксные индексы</strong></h5>

<p>Локальные партиционированные индексы могут быть либо префиксные, либо непрефиксные.</p>

<p>Подтипы индекса определяются следующим образом:</p>

<ul>
  <li>
    <p>Локальные префиксные индексы<br />В этом случае ключи партиционирования находятся на переднем месте определения индекса. В примере <code class="language-plaintext highlighter-rouge">time_range_sales</code> при диапазонном партиционировании таблица партиционируется по диапазону по <code class="language-plaintext highlighter-rouge">time_id</code>. Локальный префиксный индекс этой таблицы будет иметь <code class="language-plaintext highlighter-rouge">time_id</code> в качестве первого столбца в своем списке.</p>
  </li>
  <li>
    <p>Локальные непрефиксные индексы<br />В этом случае ключи партиционирования не находятся на переднем месте списка индексированных столбцов и вообще не должны быть в списке. В примере <code class="language-plaintext highlighter-rouge">hash_sales_idx</code> в локальных партиционированных индексах индекс является локальным непрефиксным, поскольку ключ партиционирования <code class="language-plaintext highlighter-rouge">product_id</code> не находится на переднем месте.</p>
  </li>
</ul>

<p>Оба типа индексов могут использовать преимущества исключения партиций (также называемого сокращением партиций), которое происходит, когда оптимизатор ускоряет доступ к данным, исключая партиции из рассмотрения. Может ли запрос удалять партиции, зависит от предиката запроса. Запрос, использующий локальный префиксный индекс, всегда допускает исключение индексной партиции, в то время как запрос, использующий локальный непрефиксный индекс, может этого и не делать.</p>

<h5 id="хранение-локальные-индексных-партиций"><strong>Хранение локальные индексных партиций</strong></h5>

<p>Как и табличная партиция, локальная индексная партиция хранится в своем собственном сегменте. Каждый сегмент содержит часть общих данных индекса. Таким образом, локальный индекс, состоящий из четырех партиций, хранится не в одном индексном сегменте, а в четырех отдельных сегментах.</p>

<h4 id="глобальные-партиционированные-индексы"><strong>Глобальные партиционированные индексы</strong></h4>

<p><strong>Глобальный партиционированный индекс</strong> – это индекс B-дерева, который партиционируется независимо от базовой таблицы, на основе которой он создан. Отдельная индексная партиция может указывать на любую или на все табличные партиции, тогда как в локально партиционированном индексе существует соотношение “один-к-одному” между индексными партициями и табличными партициями.</p>

<p>В целом, глобальные индексы полезны для приложений OLTP, где важны быстрый доступ, целостность данных и доступность. В системе OLTP таблица может быть партиционирована по одному ключу, например, по столбцу <code class="language-plaintext highlighter-rouge">employees.department_id</code>, но приложению может потребоваться доступ к данным с помощью множества разных ключей, например, по <code class="language-plaintext highlighter-rouge">employee_id</code> или <code class="language-plaintext highlighter-rouge">job_id</code>. Глобальные индексы могут быть полезны в этом сценарии.</p>

<p>В качестве иллюстрации предположим, что вы создаете глобальный партиционированный индекс в таблице <code class="language-plaintext highlighter-rouge">time_range_sales</code> из раздела “Диапазонное партиционирование”. В этой таблице строки для продаж за 1998 год хранятся в одной партиции, строки для продаж за 1999 год – в другой и так далее. В следующем примере создается глобальный индекс, партиционированный по диапазону, по столбцу <code class="language-plaintext highlighter-rouge">channel_id</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE INDEX time_channel_sales_idx ON time_range_sales (channel_id)
   GLOBAL PARTITION BY RANGE (channel_id)
      (PARTITION p1 VALUES LESS THAN (3),
       PARTITION p2 VALUES LESS THAN (4),
       PARTITION p3 VALUES LESS THAN (MAXVALUE));
</code></pre></div></div>

<p>Как показано на рис. 6-4, партиция глобального индекса может содержать записи, указывающие на несколько табличных партиций. Индексная партиция <code class="language-plaintext highlighter-rouge">p1</code> указывает на строки с <code class="language-plaintext highlighter-rouge">channel_id = 2</code>, индексная партиция <code class="language-plaintext highlighter-rouge">p2</code> указывает на строки с <code class="language-plaintext highlighter-rouge">channel_id = 3</code>, а индексная партиция <code class="language-plaintext highlighter-rouge">p3</code> указывает на строки с <code class="language-plaintext highlighter-rouge">channel_id in (4, 9)</code>.</p>

<p><img src="/assets/images/oracon_fig6_4.jpg" alt="OraCon_Fig6_4" /></p>

<h3 id="частичные-индексы-для-партиционированных-таблиц">Частичные индексы для партиционированных таблиц</h3>

<p><strong>Частичный индекс</strong> – это индекс, который коррелирует со свойствами индексации связанной партиционированной таблицы.</p>

<p>Корреляция позволяет указать, какие партиции таблицы индексируются. Частичные индексы обеспечивают следующие преимущества:</p>

<ul>
  <li>
    <p>Табличные партиции, которые не индексируются, позволяют избежать использования ненужного пространства для хранения индексов.</p>
  </li>
  <li>
    <p>Может улучшить производительность загрузок и запросов.<br />До Oracle Database 12c операция разделения <code class="language-plaintext highlighter-rouge">exchange</code> требовала физического обновления связанного глобального индекса, чтобы сохранить его пригодным для использования. Начиная с Oracle Database 12c, если партиции, участвующие в операции обслуживания партиций, не являются частью частичного глобального индекса, то индекс остается пригодным для использования, не требуя какого-либо обслуживания.</p>
  </li>
  <li>
    <p>Если при создании индекса индексируются только некоторые табличные партиции, и если позже проиндексируете другие, то можно уменьшить пространство сортировки, требуемое при создании индекса.</p>
  </li>
</ul>

<p>Можно включить или отключить индексацию для отдельных табличных партиций. Частичный локальный индекс не содержит используемых индексных партиций для всех табличных партиций, у которых отключена индексация. Глобальный индекс, независимо от того, партиционирован он или нет, исключает данные из всех партиций, индексация которых отключена. БД не поддерживает частичные индексы для индексов, которые накладывают уникальные ограничения.</p>

<p>На рисунке 6-5 показан тот же глобальный индекс, что и на рисунке 6-4, за исключением того, что глобальный индекс является частичным. Для табличных партиций <code class="language-plaintext highlighter-rouge">SALES_1998</code> и <code class="language-plaintext highlighter-rouge">SALES_2000</code> свойство индексации установлено в значение <code class="language-plaintext highlighter-rouge">OFF</code>, поэтому частичный глобальный индекс их не индексирует.</p>

<p><img src="/assets/images/oracon_fig6_5.jpg" alt="OraCon_Fig6_5" /></p>

<h2 id="обзор-шардированных-таблиц">Обзор шардированных таблиц</h2>

<h2 id="обзор-представлений">Обзор представлений</h2>

<h2 id="обзор-материализованных-представлений">Обзор материализованных представлений</h2>

<h2 id="обзор-последовательностей">Обзор последовательностей</h2>

<h2 id="обзор-измерений">Обзор измерений</h2>

<h2 id="обзор-синонимов">Обзор синонимов</h2>

<p><br /><br /><br /><br /><br /><br /><br /></p>
<div class="row">
  <div class="col"><div align="left"><a href="/pages/skills/oracle/concept/5indexes.html">&#8592; 5. Индексы и индексно-организованные таблицы</a></div>
  </div>
  <div class="col"><div align="right"><a href="/pages/skills/oracle/concept/7integrity.html">7. Целостность данных (Data Integrity). &#8594;</a></div> 
 </div> 
</div>

   	</div>
</div></section>

    <footer class="footer hexlet-footer py-5 mt-5 text-muted">
  <div class="container">
    <div class="row mt-1">
      <div class="col-12 text-center">
        <a href="https://aveligzhanin.github.io/">Велигжанин Андрей</a> — Программист-разработчик C++ и Oracle.
      </div>
    </div>
  </div>
</footer>

  </body>
</html>